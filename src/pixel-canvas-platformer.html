<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Canvas — Platformer Demo</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #050510;
    display: flex; align-items: center; justify-content: center;
    width: 100vw; height: 100vh; overflow: hidden;
  }
  canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
  #hint {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    color: #444; font: 9px monospace; white-space: pre; text-align: center;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="screen"></canvas>
<div id="hint">WASD/ARROWS: move  |  Z/SPACE: jump  |  UP near ladder: climb  |  X: attack  |  E/Q: cycle weapon</div>

<script type="module">

import * as Engine from './pixelGameEngine/index.js';

const {
  // Config
  TILE_SIZE,
  // Assets
  buildSpriteCache, buildPaletteSwap,
  // World / Tilemap
  worldState, camera, registerTileAnims, drawTilemap,
  // Renderer
  clearBuffer, flushBuffer, fillRectPx, fillRectWorld, drawText, drawBox, blendPixel,
  // Physics
  spatialHash,
  // ECS
  world,
  // Input
  input,
  // Sound
  sound,
  // Animation
  createAnimator, animatorPlay, animatorUpdate, animatorSprite,
  // Particles
  emitBurst, updateParticles, renderParticles,
  // Scene
  registerScenes, loadScene, clearSceneEntities,
  setNpcClipFactory, spawnSceneNpcs, spawnSceneChests,
  // Flags
  setFlag, clearFlag, getFlag, hasFlags, onFlags,
  // Dialog
  dialog, sysDialog, renderDialog,
  // Cutscene
  cutscene,
  // Combat
  sysSwing, sysProjectile, sysDamage,
  // Enemy
  sysEnemy, sysEnemyAI, spawnEnemy, spawnRangedEnemy,
  // Spawner
  createSpawner, sysSpawner,
  // Chest
  sysChestLoot,
  // Save/Load
  renderSaveNote, showNote,
  // Game loop systems
  engineTick, sysInput, sysAI, sysMovement, sysSpatialHash,
  sysAnimation, sysCamera, sysSceneTransition, sysRender,
  // HUD
  hud, renderHUD,
  // Minimap
  renderMinimap,
  // Transition
  renderTransitionOverlay,
  // Scene exports (re-exported from scene.js)
  _scenes, sceneTransition,
} = Engine;

'use strict';

// ================================================================
// SPRITES
// ================================================================
const SPRITES = {
  sky0: [
    30,30,30,30,30,30,30,30, 30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30, 30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30, 30,30,30,30,30,30,30,30,
    30,30,30,30,30,30,30,30, 30,30,30,30,30,30,30,30,
  ],
  pl_floor: [
    22,22,22,22,22,22,22,22, 20,20,20,20,20,20,20,20,
    21,21,21,21,21,21,21,21, 22,22,22,22,22,22,22,22,
    20,20,20,20,20,20,20,20, 21,21,21,21,21,21,21,21,
    22,22,22,22,22,22,22,22, 23,23,23,23,23,23,23,23,
  ],
  pl_platform: [
    21,21,21,21,21,21,21,21, 20,20,20,20,20,20,20,20,
    22,22,22,22,22,22,22,22, null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null, null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null, null,null,null,null,null,null,null,null,
  ],
  pl_ladder: [
    3,null,null,null,null,null,null,3, 3,null,null,null,null,null,null,3,
    3,5,5,5,5,5,5,3, 3,null,null,null,null,null,null,3,
    3,null,null,null,null,null,null,3, 3,null,null,null,null,null,null,3,
    3,5,5,5,5,5,5,3, 3,null,null,null,null,null,null,3,
  ],
  pl_dk: [
    null,3,3,3,3,3,3,null, 3,5,3,24,24,3,5,3,
    3,3,3,3,3,3,3,3, 3,3,4,3,3,4,3,3,
    null,4,4,4,4,4,4,null, null,4,3,3,3,3,4,null,
    null,3,null,null,null,null,3,null, null,3,null,null,null,null,3,null,
  ],
  pl_princess: [
    null,null,7,7,7,7,null,null, null,7,6,7,7,6,7,null,
    null,7,7,7,7,7,7,null, null,27,27,27,27,27,27,null,
    27,27,27,27,27,27,27,27, null,27,6,6,6,6,27,null,
    null,null,6,null,null,6,null,null, null,null,6,null,null,6,null,null,
  ],
  pl_barrel: [
    null,26,26,26,26,26,26,null, 26,27,4,5,5,4,27,26,
    26,4,5,20,4,5,4,26, 26,5,20,4,4,20,5,26,
    26,4,5,4,20,4,5,26, 26,4,4,5,5,4,4,26,
    26,27,4,4,4,4,27,26, null,26,26,26,26,26,26,null,
  ],
  pl_idle: [
    null,null,6,6,6,6,null,null, null,6,24,6,6,24,6,null,
    null,6,6,6,6,6,6,null, null,16,16,16,16,16,16,null,
    16,16,5,16,16,5,16,16, null,16,5,5,5,5,16,null,
    null,5,null,null,null,null,5,null, null,5,null,null,null,null,5,null,
  ],
  pl_walk0: [
    null,null,6,6,6,6,null,null, null,6,24,6,6,24,6,null,
    null,6,6,6,6,6,6,null, null,16,16,16,16,16,16,null,
    16,16,5,16,16,5,16,16, null,16,5,5,5,5,16,null,
    null,5,5,null,null,5,null,null, null,null,5,null,null,null,null,null,
  ],
  pl_walk1: [
    null,null,6,6,6,6,null,null, null,6,24,6,6,24,6,null,
    null,6,6,6,6,6,6,null, null,16,16,16,16,16,16,null,
    16,16,5,16,16,5,16,16, null,16,5,5,5,5,16,null,
    null,null,null,null,5,5,null,null, null,null,null,null,null,5,null,null,
  ],
  pl_jump: [
    null,null,6,6,6,6,null,null, null,6,24,6,6,24,6,null,
    null,6,6,6,6,6,6,null, 16,null,16,16,16,16,null,16,
    null,16,5,16,16,5,16,null, null,16,5,5,5,5,16,null,
    null,null,5,null,null,5,null,null, null,null,5,null,null,5,null,null,
  ],
  pl_climb: [
    null,null,6,6,6,6,null,null, null,6,24,6,6,24,6,null,
    null,6,6,6,6,6,6,null, null,16,16,16,16,16,16,null,
    16,null,5,16,16,5,null,16, null,16,5,5,5,5,16,null,
    null,5,null,null,null,null,5,null, null,null,5,null,null,5,null,null,
  ],

  // ---- Enemy: red goblin, two walk frames ----
  // Palette: 26=red, 27=pink-red, 24=dark-gray (eyes), 4=orange, 3=brown
  pl_enemy0: [
    null,null,26,26,26,26,null,null, null,26,24,26,26,24,26,null,
    null,26,26,27,27,26,26,null,     null,4,4,4,4,4,4,null,
       4,4,26,4,4,26,4,4,           null,4,26,26,26,26,4,null,
    null,3,26,null,null,26,3,null,   null,3,null,null,null,null,3,null,
  ],
  pl_enemy1: [
    null,null,26,26,26,26,null,null, null,26,24,26,26,24,26,null,
    null,26,26,27,27,26,26,null,     null,4,4,4,4,4,4,null,
       4,4,26,4,4,26,4,4,           null,4,26,26,26,26,4,null,
    null,26,3,null,null,3,26,null,   null,null,3,null,null,3,null,null,
  ],

  // ---- Sword swing: diagonal slash, tip upper-right (facing right) ----
  // flipX = true  => facing left
  // flipY = true  => tip lower-right (downward swing, not used here)
  pl_sword_swing: [
    null,null,null,null,null,null,7,20,
    null,null,null,null,null,7,20,null,
    null,null,null,null,7,20,null,null,
    null,null,null,7,20,null,null,null,
    null,null,7,20,null,null,null,null,
    null,7,20,null,null,null,null,null,
       7,20,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],

  // ---- Axe swing: wide circular arc ----
  pl_axe_swing: [
    null,null,null,3,3,null,null,null,
    null,null,3,null,null,3,null,null,
    null,3,null,4,4,null,3,null,
       3,null,4,26,26,4,null,3,
    null,3,null,4,4,null,3,null,
    null,null,3,null,null,3,null,null,
    null,null,null,3,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],

  // ---- Arrow: horizontal, tip on right (flipX for leftward flight) ----
  pl_arrow: [
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,7,
    null,5,5,5,5,5,5,5,
    null,null,null,null,null,null,null,7,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],

  // ---- Magic bolt: symmetric orb (all-direction safe) ----
  pl_bolt: [
    null,null,null,null,null,null,null,null,
    null,null,16,16,16,null,null,null,
    null,16,18,19,18,16,null,null,
    null,16,19,20,19,16,null,null,
    null,16,18,19,18,16,null,null,
    null,null,16,16,16,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
};

buildSpriteCache(SPRITES);

// ================================================================
// SOUND
// ================================================================
sound.registerTracks({
  game: {
    bpm: 160, loop: true,
    channels: [
      { instrument: 'square',
        notes: 'C5:0.5 E5:0.5 G5:0.5 E5:0.5 C5:0.5 D5:0.5 F5:0.5 D5:0.5 B4:0.5 D5:0.5 F5:0.5 D5:0.5 C5:2' },
      { instrument: 'triangle',
        notes: 'C3:2 G3:2 F3:2 G3:2 C3:2 G3:2 A3:2 G3:2 C3:2 G3:2 F3:2 E3:2 C3:4' },
    ],
  },
});

sound.registerSFX({
  jump:        { bpm:960, channels:[{ instrument:'square',   notes:'C5:0.05 E5:0.05 G5:0.08' }] },
  die:         { bpm:480, channels:[{ instrument:'square',   notes:'G4:0.1 F4:0.1 E4:0.1 D4:0.15 C4:0.2' }] },
  win:         { bpm:240, channels:[{ instrument:'square',   notes:'C5:0.15 E5:0.15 G5:0.15 C6:0.4' }] },
  score:       { bpm:960, channels:[{ instrument:'triangle', notes:'E6:0.05 G6:0.08' }] },
  hurt:        { bpm:480, channels:[{ instrument:'square',   notes:'A4:0.06 G4:0.1' }] },
  sword_swing: { bpm:960, channels:[{ instrument:'square',   notes:'G5:0.03 C5:0.05' }] },
  axe_swing:   { bpm:480, channels:[{ instrument:'square',   notes:'D4:0.06 A3:0.09' }] },
  bow_fire:    { bpm:960, channels:[{ instrument:'triangle', notes:'A5:0.04 E5:0.07' }] },
  wand_fire:   { bpm:480, channels:[{ instrument:'sine',     notes:'E6:0.04 G6:0.04 C7:0.08' }] },
  enemy_die:   { bpm:480, channels:[{ instrument:'square',   notes:'A4:0.05 F4:0.05 C4:0.1' }] },
  weapon_swap: { bpm:960, channels:[{ instrument:'triangle', notes:'C6:0.04' }] },
});

// ================================================================
// PHYSICS CONSTANTS
// ================================================================
const GRAVITY          = 300;
const JUMP_VY          = -140;
const WALK_SPEED       = 55;
const BARREL_VX        = 32;
const BARREL_SPAWN_RATE = 4.0;

setHitbox(1, 1, 6, 7);

const PLAT_ROWS = [1, 4, 7, 10, 13];

// ================================================================
// WEAPON DEFINITIONS
// ================================================================
const WEAPONS = {
  sword: {
    name: 'SWORD', type: 'melee',
    damage: 1, cooldownMax: 0.30,
    swingW: 14, swingH: 10, swingLife: 0.13,
    swingSprite: 'pl_sword_swing', knockback: 65,
    sfx: 'sword_swing', team: 'player',
  },
  axe: {
    name: 'AXE', type: 'melee',
    damage: 2, cooldownMax: 0.70,
    swingW: 14, swingH: 14, swingLife: 0.20,
    swingSprite: 'pl_axe_swing', knockback: 110,
    sfx: 'axe_swing', team: 'player',
  },
  bow: {
    name: 'BOW', type: 'ranged',
    damage: 1, cooldownMax: 0.50,
    projSprite: 'pl_arrow', projSpeed: 145, projLife: 1.2,
    piercing: false, knockback: 20,
    sfx: 'bow_fire', team: 'player',
  },
  wand: {
    name: 'WAND', type: 'spell',
    damage: 2, cooldownMax: 0.55,
    projSprite: 'pl_bolt', projSpeed: 105, projLife: 1.6,
    piercing: true, knockback: 35,   // bolt passes through multiple enemies
    sfx: 'wand_fire', team: 'player',
  },
};

const WEAPON_ORDER = ['sword', 'axe', 'bow', 'wand'];
let weaponIdx      = 0;
let weaponCooldown = 0;

// ================================================================
// SCENE BUILDER
// ================================================================
function buildPlatformerScene(cols, rows) {
  const bg  = Array.from({length: rows}, () => Array(cols).fill('sky0'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, () => Array(cols).fill(false));

  for (let r = 16; r <= 17; r++)
    for (let c = 0; c < cols; c++) { bg[r][c] = 'pl_floor'; col[r][c] = true; }

  for (let c = 0; c < cols; c++)  obj[1][c]  = 'pl_platform';
  for (let c = 5; c < cols; c++)  obj[4][c]  = 'pl_platform';
  for (let c = 0; c <= 14; c++)   obj[7][c]  = 'pl_platform';
  for (let c = 5; c < cols; c++)  obj[10][c] = 'pl_platform';
  for (let c = 0; c <= 14; c++)   obj[13][c] = 'pl_platform';

  for (let r = 14; r <= 15; r++) obj[r][13] = 'pl_ladder';
  for (let r = 11; r <= 12; r++) obj[r][6]  = 'pl_ladder';
  for (let r = 8;  r <= 9;  r++) obj[r][13] = 'pl_ladder';
  for (let r = 5;  r <= 6;  r++) obj[r][6]  = 'pl_ladder';
  for (let r = 2;  r <= 3;  r++) obj[r][13] = 'pl_ladder';

  bg[13][13] = 'pl_ladder';
  bg[10][6]  = 'pl_ladder';
  bg[7][13]  = 'pl_ladder';
  bg[4][6]   = 'pl_ladder';
  bg[1][13]  = 'pl_ladder';

  obj[0][1]  = 'pl_dk';
  obj[0][18] = 'pl_princess';

  return { bg, objects: obj, collision: col };
}

const cols = 20, rows = 18;
const { bg, objects, collision } = buildPlatformerScene(cols, rows);

const SCENE = {
  worldCols: cols, worldRows: rows,
  bgColor: 30,
  playerStart: { tileX: 2, tileY: 14 },
  music: 'game',
  layerBG:        bg,
  layerObjects:   objects,
  layerCollision: collision,
  portals: [], npcs: [],
};

registerScenes({ game: SCENE });

// ================================================================
// LADDER HELPERS
// ================================================================
const ladderSet     = new Set();  // real + virtual: used to CONTINUE climbing
const ladderGrabSet = new Set();  // real tiles only: used to INITIATE climbing

// Extend ladder detection through each platform row and the row above it.
// Keeps the player on the ladder until their feet clear the platform top,
// allowing checkPlatformLand to snap them correctly.
const LADDER_EXITS = [
  { c: 13, platRow: 13 }, { c: 6, platRow: 10 },
  { c: 13, platRow: 7  }, { c: 6, platRow: 4  },
  { c: 13, platRow: 1  },
];

for (let r = 0; r < rows; r++)
  for (let c = 0; c < cols; c++)
    if (objects[r][c] === 'pl_ladder') {
      ladderSet.add(`${c},${r}`);
      ladderGrabSet.add(`${c},${r}`);
    }

// Virtual exit tiles: extend continuation only, never grab
for (const { c, platRow } of LADDER_EXITS) {
  ladderSet.add(`${c},${platRow}`);
  ladderSet.add(`${c},${platRow - 1}`);
}

function ladderAt(tx, ty)       { return ladderSet.has(`${tx},${ty}`); }
function ladderGrabAt(tx, ty)   { return ladderGrabSet.has(`${tx},${ty}`); }

function playerOverlapsLadder(px, py) {
  const cx = ((px + 4) / TILE_SIZE) | 0;
  const cy = ((py + 4) / TILE_SIZE) | 0;
  return ladderAt(cx, cy) || ladderAt(cx, cy - 1);
}

function playerCanGrabLadder(px, py) {
  const cx = ((px + 4) / TILE_SIZE) | 0;
  const cy = ((py + 4) / TILE_SIZE) | 0;
  return ladderGrabAt(cx, cy) || ladderGrabAt(cx, cy - 1);
}

// ================================================================
// ONE-WAY PLATFORM COLLISION
// ================================================================
function checkPlatformLand(px, py, newPy) {
  if (newPy <= py) return null;
  const tx0     = ((px + HBX) / TILE_SIZE) | 0;
  const tx1     = ((px + HBX + HBW - 1) / TILE_SIZE) | 0;
  const oldFeet = py   + HBY + HBH - 1;
  const newFeet = newPy + HBY + HBH - 1;
  for (const pr of PLAT_ROWS) {
    const platTop = pr * TILE_SIZE;
    if (oldFeet < platTop && newFeet >= platTop) {
      for (let tx = tx0; tx <= tx1; tx++)
        if (objects[pr]?.[tx] === 'pl_platform')
          return platTop - HBH - HBY;
    }
  }
  return null;
}

function isOnPlatform(px, py) {
  const tx0 = ((px + HBX) / TILE_SIZE) | 0;
  const tx1 = ((px + HBX + HBW - 1) / TILE_SIZE) | 0;
  const feetTile = ((py + HBY + HBH) / TILE_SIZE) | 0;
  for (let tx = tx0; tx <= tx1; tx++)
    if (objects[feetTile]?.[tx] === 'pl_platform') return true;
  return false;
}

// ================================================================
// GAME STATE
// ================================================================
let score       = 0;
let lives       = 3;
let gameState   = 'play';
let deadTimer   = 0;
let winTimer    = 0;
let barrelTimer = 0;
let nextBarrelDir = 1;
let climbing    = false;
let vy          = 0;
let grounded    = false;
let facingRight = true;

// ================================================================
// PLAYER ENTITY
// ================================================================
playerId = world.createEntity({
  persistent: true,
  player:     true,
  transform:  { x: 2 * TILE_SIZE, y: 14 * TILE_SIZE },
  velocity:   { dx: 0, dy: 0, speed: WALK_SPEED },
  animator:   createAnimator({
    idle:  { frames: ['pl_idle'],               durations: 0.20 },
    walk:  { frames: ['pl_walk0', 'pl_walk1'],  durations: 0.16 },
    jump:  { frames: ['pl_jump'],               durations: 0.20 },
    climb: { frames: ['pl_climb'],              durations: 0.30 },
  }, 'idle'),
  collider: true,
  damageable: {
    hp: lives, maxHp: lives,
    iframes: 0, iframeMax: 1.5,
    team: 'player',
    onHit(vid, aid, amount) {
      if (gameState !== 'play') return;
      lives = world.get(vid, 'damageable').hp;
      gameState = 'dead'; deadTimer = 2.5;
      if (lives <= 0) {
        sound.playSFX('die');
      } else {
        sound.playSFX('hurt');
        const tf = world.get(vid, 'transform');
        if (tf) emitBurst(tf.x + 4, tf.y + 4, 'hit');
      }
    },
    onDeath() { /* handled in onHit */ },
  },
});

// ================================================================
// ENEMY FACTORY
// ================================================================
function spawnEnemy(tileX, tileY, dir) {
  world.createEntity({
    transform:  { x: tileX * TILE_SIZE, y: tileY * TILE_SIZE },
    sprite:     { name: 'pl_enemy0', flipX: dir < 0 },
    enemy:      { dir, speed: 22, vy: 0, animTimer: 0 },
    damageable: {
      hp: 3, maxHp: 3,
      iframes: 0, iframeMax: 0.4,
      team: 'enemy',
      onHit(vid) {
        const tf = world.get(vid, 'transform');
        if (tf) emitBurst(tf.x + 4, tf.y + 4, 'hit');
      },
      onDeath(vid) {
        const tf = world.get(vid, 'transform');
        if (tf) emitBurst(tf.x + 4, tf.y + 4, 'levelup');
        sound.playSFX('enemy_die');
        score += 100;
        world.destroyEntity(vid);
      },
    },
    damager: { damage: 1, team: 'enemy', knockback: 45 },
  });
}

function spawnInitialEnemies() {
  for (const id of world.query('enemy')) world.destroyEntity(id);
  spawnEnemy( 7, 13, -1);
  spawnEnemy(12, 13,  1);
  spawnEnemy( 6, 10,  1);
  spawnEnemy(14, 10, -1);
  spawnEnemy( 7,  7,  1);
  spawnEnemy( 5,  4,  1);
  spawnEnemy(15,  4, -1);
}

// ================================================================
// ENEMY AI SYSTEM
// Walk horizontally; reverse on wall or platform edge.
// Each enemy carries its own vy for gravity.
// ================================================================
function sysEnemyAI(delta) {
  for (const id of world.query('enemy', 'transform', 'sprite')) {
    const tf = world.get(id, 'transform');
    const e  = world.get(id, 'enemy');
    const sp = world.get(id, 'sprite');
    if (!tf || !e || !sp) continue;

    // ── Gravity ──────────────────────────────────────────────
    e.vy += GRAVITY * delta;
    const newY = tf.y + e.vy * delta;
    const snap = checkPlatformLand(tf.x, tf.y, newY);
    if (snap !== null) {
      tf.y = snap; e.vy = 0;
    } else {
      const cY = Math.min(worldState.h - TILE_SIZE, newY);
      if (collidesAt(tf.x, cY)) e.vy = 0;
      else tf.y = cY;
    }

    // ── Horizontal (wall + ledge detection) ──────────────────
    const nextX   = tf.x + e.dir * e.speed * delta;
    const wallHit = collidesAt(Math.max(0, Math.min(worldState.w - TILE_SIZE, nextX)), tf.y);

    const edgeTX = ((tf.x + e.dir * (TILE_SIZE + 2)) / TILE_SIZE) | 0;
    const edgeTY = ((tf.y + TILE_SIZE + 3) / TILE_SIZE) | 0;
    const floorAhead = isSolid(edgeTX, edgeTY)
                    || objects[edgeTY]?.[edgeTX] === 'pl_platform'
                    || objects[edgeTY]?.[edgeTX] === 'pl_floor';

    if (wallHit || !floorAhead) {
      e.dir *= -1;
    } else {
      tf.x = Math.max(0, Math.min(worldState.w - TILE_SIZE, nextX));
    }

    // ── Sprite ───────────────────────────────────────────────
    sp.flipX = e.dir < 0;
    e.animTimer += delta;
    if (e.animTimer >= 0.25) {
      e.animTimer -= 0.25;
      sp.name = sp.name === 'pl_enemy0' ? 'pl_enemy1' : 'pl_enemy0';
    }
  }
}

// ================================================================
// BARREL SPAWNER + PHYSICS
// ================================================================
function spawnBarrel() {
  world.createEntity({
    transform: { x: 2 * TILE_SIZE, y: 2 * TILE_SIZE },
    velocity:  { dx: BARREL_VX * nextBarrelDir, dy: 0, speed: 0 },
    barrel:    { vy: 0, dir: nextBarrelDir },
    sprite:    { name: 'pl_barrel', flipX: false },
    damager:   { damage: 1, team: 'enemy', knockback: 60 },
  });
  nextBarrelDir *= -1;
}

function sysBarrelSpawner(delta) {
  if (gameState !== 'play') return;
  barrelTimer += delta;
  if (barrelTimer >= BARREL_SPAWN_RATE) { barrelTimer = 0; spawnBarrel(); }
}

function sysBarrelPhysics(delta) {
  for (const id of world.query('transform', 'barrel')) {
    const tf = world.get(id, 'transform');
    const b  = world.get(id, 'barrel');
    if (!tf || !b) continue;

    b.vy += GRAVITY * delta;

    const newX = tf.x + b.dir * BARREL_VX * delta;
    if (newX < 0 || newX + TILE_SIZE > worldState.w) { world.destroyEntity(id); continue; }
    tf.x = newX;

    const newY = tf.y + b.vy * delta;
    const snap = checkPlatformLand(tf.x, tf.y, newY);
    if (snap !== null) { tf.y = snap; b.vy = 0; }
    else {
      const cY = Math.min(worldState.h - TILE_SIZE, newY);
      if (collidesAt(tf.x, cY)) b.vy = 0;
      else tf.y = cY;
    }

    if (tf.y + TILE_SIZE >= worldState.h - TILE_SIZE) {
      score += 50; sound.playSFX('score');
      world.destroyEntity(id);
    }
  }
}

// ================================================================
// WIN CHECK
// ================================================================
function checkWin(tf) {
  if (gameState !== 'play') return;
  const feetY = tf.y + HBY + HBH;
  if (feetY <= TILE_SIZE && (grounded || isOnPlatform(tf.x, tf.y) || climbing)) {
    gameState = 'win'; winTimer = 3.5;
    score += 1000;
    sound.playSFX('win');
  }
}

// ================================================================
// PLAYER PHYSICS + INPUT + ATTACK
// ================================================================
function sysPlayerPhysics(delta) {
  if (gameState !== 'play') return;

  const tf   = world.get(playerId, 'transform');
  const anim = world.get(playerId, 'animator');
  if (!tf || !anim) return;

  // ── Weapon cycle (E / Q) ──────────────────────────────────
  if (input.pressed('itemNext')) {
    weaponIdx = (weaponIdx + 1) % WEAPON_ORDER.length;
    weaponCooldown = 0;
    sound.playSFX('weapon_swap');
  }
  if (input.pressed('itemPrev')) {
    weaponIdx = (weaponIdx + WEAPON_ORDER.length - 1) % WEAPON_ORDER.length;
    weaponCooldown = 0;
    sound.playSFX('weapon_swap');
  }

  // ── Cooldown tick ─────────────────────────────────────────
  if (weaponCooldown > 0) weaponCooldown = Math.max(0, weaponCooldown - delta);

  // ── Attack (X) ────────────────────────────────────────────
  if (input.pressed('attack') && weaponCooldown <= 0) {
    const weapon = WEAPONS[WEAPON_ORDER[weaponIdx]];
    // Direction: hold UP to fire/swing upward, else use facing direction.
    const ax = input.axis();
    let dirX = facingRight ? 1 : -1;
    let dirY = 0;
    if (input.held('up') || ax.y < -0.15) { dirX = 0; dirY = -1; }
    spawnAttack(playerId, weapon, tf.x, tf.y, dirX, dirY);
    weaponCooldown = weapon.cooldownMax;
    sound.playSFX(weapon.sfx);
  }

  // ── Movement ──────────────────────────────────────────────
  const ax = input.axis();
  let dx = 0;
  if (input.held('left')  || ax.x < -0.15) { dx = -WALK_SPEED; facingRight = false; }
  if (input.held('right') || ax.x >  0.15) { dx =  WALK_SPEED; facingRight = true;  }

  const wantClimb   = input.held('up')   || ax.y < -0.15;
  const wantDescend = input.held('down') || ax.y >  0.15;
  const canGrabLadder = playerOverlapsLadder(tf.x, tf.y);

  // Ladder.
  if (climbing) {
    if (!canGrabLadder) { climbing = false; }
    else {
      vy = 0;
      const climbDy = wantClimb ? -WALK_SPEED * 0.7 : wantDescend ? WALK_SPEED * 0.7 : 0;
      tf.y += climbDy * delta;
      tf.y  = Math.max(0, Math.min(worldState.h - TILE_SIZE, tf.y));
      tf.x += dx * delta;
      tf.x  = Math.max(0, Math.min(worldState.w - TILE_SIZE, tf.x));
      animatorPlay(anim, 'climb');
      checkWin(tf);
      return;
    }
  }
  if (wantClimb && playerCanGrabLadder(tf.x, tf.y) && !climbing) { climbing = true; vy = 0; return; }

  // Gravity.
  vy += GRAVITY * delta;

  // Jump.
  if ((input.pressed('action') || input.pressed('up')) && (grounded || isOnPlatform(tf.x, tf.y))) {
    vy = JUMP_VY; grounded = false;
    sound.playSFX('jump');
  }

  // Horizontal.
  const newX = Math.max(0, Math.min(worldState.w - TILE_SIZE, tf.x + dx * delta));
  if (!collidesAt(newX, tf.y)) tf.x = newX;

  // Vertical.
  const desiredY = tf.y + vy * delta;
  const platSnap = checkPlatformLand(tf.x, tf.y, desiredY);
  if (platSnap !== null) {
    tf.y = platSnap; vy = 0; grounded = true;
  } else {
    const cY = Math.max(0, Math.min(worldState.h - TILE_SIZE, desiredY));
    if (collidesAt(tf.x, cY)) {
      if (vy > 0) grounded = true;
      vy = 0;
    } else {
      tf.y = cY;
      grounded = isGrounded(tf.x, tf.y) || isOnPlatform(tf.x, tf.y);
    }
  }
  if (tf.y + TILE_SIZE >= worldState.h - TILE_SIZE) {
    tf.y = worldState.h - 2 * TILE_SIZE; vy = 0; grounded = true;
  }

  // Animation.
  if      (!grounded && !climbing) animatorPlay(anim, 'jump');
  else if (dx !== 0)               animatorPlay(anim, 'walk');
  else                             animatorPlay(anim, 'idle');
  anim.flipX = !facingRight;

  // Win.
  checkWin(tf);
}

// ================================================================
// GAME STATE TRANSITIONS
// ================================================================
function _resetPlayer() {
  climbing = false; vy = 0; grounded = false;
  const tf = world.get(playerId, 'transform');
  if (tf) { tf.x = 2 * TILE_SIZE; tf.y = 14 * TILE_SIZE; }
}

function _resetDamageable(hp) {
  const d = world.get(playerId, 'damageable');
  if (d) { d.hp = hp; d.maxHp = hp; d.iframes = 0; }
}

function sysGameState(delta) {
  if (gameState === 'dead') {
    deadTimer -= delta;
    if (deadTimer <= 0) {
      if (lives <= 0) {
        gameState = 'over';
      } else {
        gameState = 'play'; barrelTimer = 0;
        for (const id of world.query('barrel')) world.destroyEntity(id);
        _resetPlayer();
        _resetDamageable(lives);
      }
    }
  } else if (gameState === 'win') {
    winTimer -= delta;
    if (winTimer <= 0) {
      gameState = 'play'; barrelTimer = 0; weaponCooldown = 0;
      for (const id of world.query('barrel'))     world.destroyEntity(id);
      for (const id of world.query('swing'))      world.destroyEntity(id);
      for (const id of world.query('projectile')) world.destroyEntity(id);
      _resetPlayer();
      _resetDamageable(lives);
      spawnInitialEnemies();
    }
  }
}

// ================================================================
// HUD
// ================================================================
const CD_BAR_W = 28, CD_BAR_H = 2;

function renderHUD() {
  fillRectPx(0, 0, LOGICAL_W, 8, 0);

  drawText(`SCORE:${score}`, 2, 1, 7);

  const livesStr = `LIVES:${Math.max(0, lives)}`;
  drawText(livesStr, LOGICAL_W - livesStr.length * CHAR_W - 2, 1, 27);

  // Weapon name centred.
  const weapon = WEAPONS[WEAPON_ORDER[weaponIdx]];
  const nameX  = ((LOGICAL_W - weapon.name.length * CHAR_W) / 2) | 0;
  drawText(weapon.name, nameX, 1, 20);

  // Cooldown bar: fills from left as cooldown expires.
  const barX = ((LOGICAL_W - CD_BAR_W) / 2) | 0;
  fillRectPx(barX, 7, CD_BAR_W, CD_BAR_H, 13);   // dark track
  if (weaponCooldown < weapon.cooldownMax) {
    const frac = 1 - weaponCooldown / weapon.cooldownMax;
    fillRectPx(barX, 7, Math.round(CD_BAR_W * frac), CD_BAR_H, 20); // white fill
  }
}

// ================================================================
// OVERLAYS
// ================================================================
function renderOverlay(elapsed) {
  if (gameState === 'dead' && lives > 0) {
    drawBox(44, 60, 72, 24, 1, 27);
    drawText('OH NO!', 58, 65, 27);
    drawText(`${lives} LIVES LEFT`, 48, 74, 20);
  } else if (gameState === 'over') {
    drawBox(36, 56, 88, 32, 1, 26);
    drawText('GAME OVER', 50, 61, 26);
    drawText(`SCORE: ${score}`, 50, 71, 7);
    if (Math.floor(elapsed * 2) % 2 === 0) drawText('Z TO RETRY', 48, 80, 21);
  } else if (gameState === 'win') {
    drawBox(36, 56, 88, 32, 1, 7);
    drawText('YOU WIN!', 54, 61, 7);
    drawText(`+1000 PTS`, 54, 71, 20);
    drawText('NEXT ROUND...', 42, 80, 21);
  }

  if (gameState === 'over' && input.pressed('action')) {
    score = 0; lives = 3;
    gameState = 'play'; barrelTimer = 0; weaponCooldown = 0; weaponIdx = 0;
    for (const id of world.query('barrel'))     world.destroyEntity(id);
    for (const id of world.query('swing'))      world.destroyEntity(id);
    for (const id of world.query('projectile')) world.destroyEntity(id);
    _resetPlayer();
    _resetDamageable(3);
    spawnInitialEnemies();
  }
}

// ================================================================
// MAIN LOOP
// ================================================================
let elapsed = 0, lastTime = 0;

loadScene('game');
{ const tf = world.get(playerId, 'transform');
  if (tf) { tf.x = 2 * TILE_SIZE; tf.y = 14 * TILE_SIZE; } }
spawnInitialEnemies();

function loop(ts) {
  const delta = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts; elapsed += delta;

  engineTick(delta);
  input.update();

  // -- Logic (order matters: physics before damage) --
  sysGameState(delta);
  sysPlayerPhysics(delta);
  sysBarrelSpawner(delta);
  sysBarrelPhysics(delta);
  sysEnemyAI(delta);
  sysDamage(delta);      // barrel/enemy→player; swing/projectile→enemy
  sysProjectile(delta);  // move & cull projectiles
  sysSwing(delta);       // cull expired melee hitboxes
  sysAnimation(delta);

  // -- Render --
  clearBuffer(30);
  drawTilemap(SCENE.layerBG,      elapsed);
  drawTilemap(SCENE.layerObjects, elapsed);
  sysRender();
  renderHUD();
  renderOverlay(elapsed);
  renderSaveNote();
  flushBuffer();

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
