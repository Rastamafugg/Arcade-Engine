<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Canvas v5 — Overworld Demo</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    display: flex; align-items: center; justify-content: center;
    width: 100vw; height: 100vh; overflow: hidden;
  }
  canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
  #debug {
    position: fixed; top: 8px; left: 8px;
    color: #0f0; font: 9px/1.5 monospace; pointer-events: none; white-space: pre;
    background: rgba(0,0,0,0.55); padding: 4px 6px; border-radius: 2px;
  }
  #hint {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    color: #555; font: 9px monospace; white-space: pre; text-align: center;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="screen"></canvas>
<div id="debug"></div>
<div id="hint">WASD/ARROWS: move  |  Z/SPACE: talk  |  F5: save  |  F9: load</div>

<script src="pixel-canvas-engine.js"></script>

<script>
'use strict';
// ================================================================
// SPRITES
// ================================================================
const SPRITES = {
  // Terrain
  grass: [
     9, 9, 8, 9, 9, 9, 8, 9,   8, 9, 9, 9, 8, 9, 9, 8,
     9, 9, 8, 9, 9, 8, 9, 9,  11,11,11, 9,11,11,11,11,
    11,11,11,11,11,11,11,11,  12,11,11,11,12,11,11,12,
    11,11,12,11,11,11,12,11,  11,12,11,11,11,12,11,11,
  ],
  stone: [
    22,21,22,22,22,22,21,22,  21,22,22,22,21,22,22,22,
    22,22,22,21,22,22,22,21,  23,23,23,23,23,23,23,23,
    22,22,22,23,22,22,22,23,  22,23,22,22,22,23,22,22,
    23,22,22,22,23,22,22,22,  22,22,23,22,22,22,23,22,
  ],
  wall: [
    24,24,28,24,24,24,28,24,  28,29,29,29,29,29,29,28,
    24,29,24,24,24,24,29,24,  24,29,24,24,24,24,29,24,
    28,29,29,29,29,29,29,28,  24,29,24,24,24,24,29,24,
    24,29,24,24,24,24,29,24,  28,29,29,29,29,29,29,28,
  ],
  cave_wall: [
    30,30,29,30,30,30,29,30,  29,14,14,14,14,14,14,29,
    30,14,30,30,30,30,14,30,  30,14,30,31,31,30,14,30,
    29,14,14,14,14,14,14,29,  30,14,30,30,30,30,14,30,
    30,14,31,30,30,31,14,30,  29,14,14,14,14,14,14,29,
  ],
  cave_floor: [
    13,13,24,13,13,13,24,13,  24,13,13,13,24,13,13,24,
    13,13,24,13,13,24,13,13,  23,23,23,13,23,23,23,23,
    23,23,23,23,23,23,23,23,  13,23,23,23,13,23,23,13,
    23,13,23,23,23,13,23,23,  23,23,13,23,23,23,13,23,
  ],
  water0: [
    18,17,18,18,18,17,18,18,  18,18,17,18,18,18,17,18,
    15,18,18,18,15,18,18,18,  18,15,18,18,18,15,18,18,
    18,18,18,15,18,18,18,15,  18,18,15,18,18,18,15,18,
    17,18,18,18,17,18,18,18,  18,17,18,18,18,17,18,18,
  ],
  water1: [
    18,18,17,18,18,18,17,18,  17,18,18,18,17,18,18,18,
    18,18,18,15,18,18,18,15,  18,18,15,18,18,18,15,18,
    15,18,18,18,15,18,18,18,  18,15,18,18,18,15,18,18,
    18,18,18,17,18,18,18,17,  18,18,17,18,18,18,17,18,
  ],
  // Decor
  tree: [
    null,null, 8,null,null, 8,null,null,
    null, 8,   8,  8,  8,  8,  8,null,
       8,  8,  8,  9,  9,  8,  8,  8,
    null, 8,   9,  8,  8,  9,  8,null,
    null,null, 8,  8,  8,  8,null,null,
    null,null,null, 3,null,null,null,null,
    null,null,null, 3,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  flower: [
    null,null,null, 7,null,null,null,null,
    null,null, 7,   7,  7,null,null,null,
    null,null,null, 7,null,null,null,null,
    null, 8,null,null,null, 7,null,null,
       8, 9,  8,null,null, 7,  7,null,
    null, 8,null,null,null, 7,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  crystal: [
    null,null,19,null,null,null,null,null,
    null,19,  18,  19,null,null,null,null,
      19, 18,  20,  18,  19,null,null,null,
    null,19,  18,  19,null,null,null,null,
    null,null,19,null,null,19,  18,  19,
    null,null,null,null,19, 18,  20,  18,
    null,null,null,null,null,19,null,null,
    null,null,null,null,null,null,null,null,
  ],
  portal: [
    null,null,25,25,25,null,null,null,
    null,25,  19,18,19,  25,null,null,
      25,19,  18,20,18,  19,  25,null,
      25,18,  20,25,20,  18,  25,null,
      25,19,  18,20,18,  19,  25,null,
    null,25,  19,18,19,  25,null,null,
    null,null,25,25,25,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  // Collectibles
  coin_item: [
    null,null, 7, 7, 7, 7,null,null,
    null, 7,  20, 7, 7, 7, 7,null,
     7,  20,  7, 7, 7, 7, 7, 7,
     7,   7,  7, 7, 7, 7, 7, 7,
     7,   7,  7, 7, 7, 7, 7, 7,
    null, 7,  7, 7, 7, 7, 7,null,
    null,null, 7, 7, 7, 7,null,null,
    null,null,null,null,null,null,null,null,
  ],
  heart_item: [
    null,27,27,null,null,27,27,null,
    27,27,27,27,27,27,27,27,
    27,27,27,27,27,27,27,27,
    27,27,27,27,27,27,27,27,
    null,27,27,27,27,27,27,null,
    null,null,27,27,27,27,null,null,
    null,null,null,27,27,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  key_item: [
    null,null, 7, 7,null,null,null,null,
    null, 7,   5, 5, 7,null,null,null,
    null, 7,   5, 5, 7,null,null,null,
    null,null, 7, 7,null, 5,null,null,
    null,null,null, 7, 5, 5, 5,null,
    null,null,null, 7,null, 5,null,null,
    null,null,null, 7,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  // NPCs
  npc_a: [
    null,null,  7,  7,  7,  7,null,null,
    null,  7, 24,  7,  7, 24,  7,null,
    null,  7,  7,  7,  7,  7,  7,null,
    null,  4,  4,  4,  4,  4,  4,null,
       4,  4,  5,  4,  4,  5,  4,  4,
    null,  4,  5,  5,  5,  5,  4,null,
    null,  5,null,null,null,null,  5,null,
    null,  5,null,null,null,null,  5,null,
  ],
  npc_b: [
    null,null,  5,  5,  5,  5,null,null,
    null,  5, 13,  5,  5, 13,  5,null,
    null,  5,  5,  5,  5,  5,  5,null,
    null, 27, 27, 27, 27, 27, 27,null,
      27, 27,  6, 27, 27,  6, 27, 27,
    null, 27,  6,  6,  6,  6, 27,null,
    null,  6,null,null,null,null,  6,null,
    null,  6,null,null,null,null,  6,null,
  ],
  // Player animation frames
  player_d0: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6, 24,  6,  6, 24,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,  5,  5,null,null,  5,null,null,
    null,null,  5,null,null,null,null,null,
  ],
  player_d1: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6, 24,  6,  6, 24,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,null,null,null,  5,  5,null,null,
    null,null,null,null,null,  5,null,null,
  ],
  player_idle: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6, 24,  6,  6, 24,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,  5,null,null,null,null,  5,null,
    null,  5,null,null,null,null,  5,null,
  ],
  player_u0: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6,  6, 24, 24,  6,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,  5,  5,null,null,  5,null,null,
    null,null,  5,null,null,null,null,null,
  ],
  player_u1: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6,  6, 24, 24,  6,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,null,null,null,  5,  5,null,null,
    null,null,null,null,null,  5,null,null,
  ],
  player_s0: [
    null,null,  6,  6,  6,null,null,null,
    null,  6, 24,  6,  6,  6,null,null,
    null,  6,  6,  6,  6,  6,null,null,
    null, 16, 16, 16, 16, 16, 16,null,
    null, 16,  5, 16, 16,  5, 16,null,
    null, 16,  5,  5,  5,  5,null,null,
    null,  5,  5,null,  5,null,null,null,
    null,null,  5,null,null,null,null,null,
  ],
  player_s1: [
    null,null,  6,  6,  6,null,null,null,
    null,  6, 24,  6,  6,  6,null,null,
    null,  6,  6,  6,  6,  6,null,null,
    null, 16, 16, 16, 16, 16, 16,null,
    null, 16,  5, 16, 16,  5, 16,null,
    null, 16,  5,  5,  5,  5,null,null,
    null,null,null,  5,  5,null,null,null,
    null,null,null,null,  5,null,null,null,
  ],
};

buildSpriteCache(SPRITES);

// ================================================================
// TILE ANIMATIONS
// ================================================================
registerTileAnims({
  water: { frames: ['water0','water1'], fps: 2 },
});

// ================================================================
// SOUND
// ================================================================
sound.registerTracks({
  overworld: {
    bpm: 140, loop: true,
    channels: [
      { instrument: 'square',
        notes: 'E5:0.5 G5:0.5 A5:1 E5:0.5 G5:0.5 B5:1 A5:0.5 G5:0.5 A5:0.5 E5:0.5 D5:2 R:1 C5:0.5 E5:0.5 G5:0.5 A5:1 F5:0.5 E5:0.5 D5:0.5 C5:0.5 E5:2 R:1' },
      { instrument: 'triangle',
        notes: 'A3:2 A3:2 F3:2 G3:2 A3:2 A3:2 G3:2 E3:2 C3:2 E3:2 F3:2 G3:2 A3:4' },
    ],
  },
  cave: {
    bpm: 70, loop: true,
    channels: [
      { instrument: 'sine',
        notes: 'A3:2 R:1 G3:1 F3:2 R:1 E3:1 D3:2 R:2 A2:4 R:2 E3:2 R:2 F3:2 R:2' },
      { instrument: 'triangle',
        notes: 'A2:4 R:4 F2:4 R:4 G2:4 R:4 A2:8 R:4' },
    ],
  },
});

sound.registerSFX({
  confirm:  { bpm:960, channels:[{ instrument:'square',   notes:'C5:0.1 E5:0.1 G5:0.2' }] },
  dialog:   { bpm:960, channels:[{ instrument:'square',   notes:'C6:0.05' }] },
  portal:   { bpm:480, channels:[{ instrument:'sine',     notes:'A4:0.1 C#5:0.1 E5:0.1 A5:0.2 R:0.1 A6:0.3' }] },
  save:     { bpm:960, channels:[{ instrument:'square',   notes:'G5:0.08 B5:0.08 D6:0.08 G6:0.15' }] },
  cancel:   { bpm:960, channels:[{ instrument:'triangle', notes:'E5:0.1 C5:0.1' }] },
  coin:     { bpm:960, channels:[{ instrument:'square',   notes:'A5:0.06 C6:0.08 E6:0.12' }] },
  hurt:     { bpm:480, channels:[{ instrument:'square',   notes:'A4:0.06 G4:0.1' }] },
  heal:     { bpm:960, channels:[{ instrument:'triangle', notes:'E5:0.08 G5:0.08 C6:0.15' }] },
});

// ================================================================
// ANIMATION CLIPS
// ================================================================
const CLIPS_PLAYER = {
  idle:      { frames: ['player_idle'],           durations: 0.2  },
  walk_down: { frames: ['player_d0','player_d1'], durations: 0.18 },
  walk_up:   { frames: ['player_u0','player_u1'], durations: 0.18 },
  walk_side: { frames: ['player_s0','player_s1'], durations: 0.18 },
};

setNpcClipFactory(sprite => ({
  idle:      { frames: [sprite], durations: 0.4 },
  walk_down: { frames: [sprite], durations: 0.3 },
  walk_up:   { frames: [sprite], durations: 0.3 },
  walk_side: { frames: [sprite], durations: 0.3 },
}));

// ================================================================
// COLLECTIBLE SYSTEM
// Items are ECS entities with a 'pickup' component.
// Checked against player position each frame.
// ================================================================
function spawnPickup(worldX, worldY, type) {
  return world.createEntity({
    transform: { x: worldX, y: worldY },
    sprite:    { name: type + '_item', flipX: false },
    pickup:    { type, collected: false },
  });
}

function sysPickups() {
  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;
  for (const id of world.query('pickup', 'transform')) {
    const p  = world.get(id, 'pickup');
    if (p.collected) continue;
    const tf = world.get(id, 'transform');
    const dx = ptf.x - tf.x, dy = ptf.y - tf.y;
    if (Math.abs(dx) < 7 && Math.abs(dy) < 7) {
      p.collected = true;
      switch (p.type) {
        case 'coin':
          hud.addCoins(1);
          sound.playSFX('coin');
          emitBurst(tf.x + 4, tf.y + 4, 'coin');
          break;
        case 'heart':
          hud.addHp(2);
          sound.playSFX('heal');
          emitBurst(tf.x + 4, tf.y + 4, 'sparkle');
          break;
        case 'key':
          setFlag('hasKey');
          hud.setItem(0, 'key_item');
          sound.playSFX('confirm');
          emitBurst(tf.x + 4, tf.y + 4, 'levelup');
          showNote('KEY OBTAINED!');
          break;
      }
      world.destroyEntity(id);
    }
  }
}

// ================================================================
// FOOTSTEP PARTICLE EMITTER
// ================================================================
let _footTimer = 0;
function sysFootsteps(delta) {
  const vel = world.get(playerId, 'velocity');
  const tf  = world.get(playerId, 'transform');
  if (!vel || !tf) return;
  const moving = vel.dx !== 0 || vel.dy !== 0;
  if (!moving) { _footTimer = 0; return; }
  _footTimer += delta;
  if (_footTimer >= 0.18) {
    _footTimer = 0;
    emitBurst(tf.x + 4, tf.y + 7, 'footstep');
  }
}

// ================================================================
// PORTAL SPARKLE EMITTER
// ================================================================
let _portalTimer = 0;
function sysPortalSparkles(delta) {
  _portalTimer += delta;
  if (_portalTimer < 0.12) return;
  _portalTimer = 0;
  const portals = _scenes[worldState.currentScene]?.portals ?? [];
  for (const p of portals) {
    const wx = p.tileX * TILE_SIZE + 4;
    const wy = p.tileY * TILE_SIZE + 4;
    emitBurst(wx, wy, 'sparkle');
  }
}

// ================================================================
// SCENE DEFINITIONS
// ================================================================
function buildOverworld(cols, rows) {
  const bg  = Array.from({length: rows}, () => Array(cols).fill('grass'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, () => Array(cols).fill(false));

  for (let r = 4; r <= 6; r++)
    for (let c = 5; c <= 9; c++) { bg[r][c] = 'water'; col[r][c] = true; }
  for (let r = 9; r <= 11; r++)
    for (let c = 6; c <= 10; c++) bg[r][c] = 'stone';
  for (let r = 20; r <= 25; r++)
    for (let c = 15; c <= 22; c++)
      if (r === 20 || r === 25 || c === 15 || c === 22)
        { obj[r][c] = 'wall'; col[r][c] = true; }

  [[1,1],[1,4],[2,8],[3,18],[6,14],[0,12],[9,25],[11,28],[16,5],[13,8],[22,2],[24,6],
   [5,32],[12,38],[20,30],[28,5],[30,12],[32,20],[25,35]].forEach(([r,c]) => {
    if (r < rows && c < cols) { obj[r][c] = 'tree'; col[r][c] = true; }
  });
  [[3,3],[4,12],[7,3],[8,18],[13,7],[19,12],[22,28],[28,15]].forEach(([r,c]) => {
    if (r < rows && c < cols) obj[r][c] = 'flower';
  });

  obj[8][35] = 'portal';
  return { bg, objects: obj, collision: col };
}

function buildCave(cols, rows) {
  const bg  = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      (r === 0 || r === rows-1 || c === 0 || c === cols-1) ? 'cave_wall' : 'cave_floor'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      r === 0 || r === rows-1 || c === 0 || c === cols-1));

  for (let r = 4; r <= 12; r++)
    for (let c = 5; c <= 14; c++)
      if ((r === 4 || r === 12 || c === 5 || c === 14) &&
          !(r === 8 && (c === 5 || c === 14)))
        { bg[r][c] = 'cave_wall'; col[r][c] = true; }

  [[2,5],[2,10],[2,16],[16,3],[16,10],[16,16],[6,8],[9,11],[7,2],[14,17]].forEach(([r,c]) => {
    if (r < rows && c < cols && !col[r][c]) obj[r][c] = 'crystal';
  });
  obj[8][1]  = 'portal'; col[8][1] = false;
  bg[8][0]   = 'cave_floor'; col[8][0] = false;
  return { bg, objects: obj, collision: col };
}

const OW_COLS = 40, OW_ROWS = 36;
const CAVE_COLS = 20, CAVE_ROWS = 18;
const { bg: owBg, objects: owObj, collision: owCol } = buildOverworld(OW_COLS, OW_ROWS);
const { bg: cvBg, objects: cvObj, collision: cvCol } = buildCave(CAVE_COLS, CAVE_ROWS);

// ================================================================
// NPC DIALOG BRANCHES — flag-gated
// Villager has four dialogue states based on quest progress.
// ================================================================
const VILLAGER_BRANCHES = [
  // Phase 4: found the crystal — celebration branch
  {
    requires: ['foundCrystal'],
    lines: [
      'YOU FOUND THE CRYSTAL!\nTHIS CALLS FOR A\nCELEBRATION!',
      'TAKE THIS AS THANKS\nFOR YOUR BRAVERY.',
    ],
    setFlags:   ['rewarded'],
    clearFlags: ['foundCrystal'],  // prevent repeating reward
    addCoins:   5,
    emit:       { x: 12*8+4, y: 12*8+4, preset: 'levelup' },
  },
  // Phase 3: entered cave, has key
  {
    requires: ['enteredCave', 'hasKey'],
    excludes: ['foundCrystal'],
    lines: [
      'A KEY FROM THE CAVE!\nYOU ARE BRAVER THAN\nI THOUGHT.',
      'THE CRYSTAL CHAMBER\nLIES DEEP WITHIN.\nGOOD LUCK!',
    ],
  },
  // Phase 2: entered cave but no key
  {
    requires: ['enteredCave'],
    excludes: ['hasKey', 'foundCrystal'],
    lines: [
      'SO YOU ENTERED THE\nCRYSTAL CAVE.',
      'DID YOU FIND ANYTHING\nINSIDE? I HEAR THERE\nIS A HIDDEN KEY...',
    ],
  },
  // Phase 1: first contact, gives coin reward
  {
    excludes: ['metVillager'],
    lines: [
      'GREETINGS, TRAVELER!\nWELCOME TO OUR VILLAGE.',
      'THE CRYSTAL CAVE LIES\nTO THE EAST. A GLOWING\nPORTAL MARKS THE WAY.',
      'FEW WHO ENTER RETURN\nTO TELL THE TALE.\nTAKE THIS FOR LUCK.',
    ],
    setFlags: ['metVillager'],
    addCoins: 3,
    runScript: [
      { cmd:'sfx', name:'coin' },
    ],
  },
  // Phase 0: default (already met, no new info)
  {
    lines: [
      'BE CAREFUL OUT THERE.\nAND KEEP AN EYE ON\nTHAT CAVE PORTAL.',
    ],
  },
];

// ================================================================
// CAVE CUTSCENE — fires once on first entry
// Sage walks toward player, delivers intro dialog, rewards health.
// ================================================================
function buildCaveEntryCutscene(sageId) {
  return [
    { cmd:'lockInput', value: true },
    { cmd:'wait', seconds: 0.4 },
    { cmd:'move', id: sageId, tx: 5, ty: 8, speed: 35 },
    { cmd:'sfx',  name: 'portal' },
    { cmd:'dialog', name: 'CAVE SAGE',
      lines: [
        'WAIT! STOP RIGHT THERE.',
        'YOU ARE THE FIRST TO\nENTER IN MANY YEARS.',
        'TAKE THIS HEART. YOU\nWILL NEED IT AHEAD.',
      ],
    },
    { cmd:'flag',  name: 'enteredCave' },
    { cmd:'call',  fn: () => { hud.addHp(2); sound.playSFX('heal'); emitBurst(4*8+4, 8*8+4, 'sparkle'); } },
    { cmd:'lockInput', value: false },
  ];
}

const SCENE_DATA = {
  overworld: (() => {
    const cols = OW_COLS, rows = OW_ROWS;
    return {
      worldCols: cols, worldRows: rows, bgColor: 0,
      playerStart: { tileX: 15, tileY: 15 },
      music: 'overworld',
      layerBG: owBg, layerObjects: owObj, layerCollision: owCol,
      portals: [
        { tileX: 35, tileY: 8, targetScene: 'cave', targetTileX: 3, targetTileY: 8 },
      ],
      npcs: [
        {
          tileX: 12, tileY: 12, sprite: 'npc_a', name: 'VILLAGER',
          dialog:         ['...'],    // fallback (overridden by branches)
          dialogBranches: VILLAGER_BRANCHES,
          patrol: {
            speed: 20, waypointIdx: 0,
            waypoints: [{x:12*8,y:12*8},{x:15*8,y:12*8},{x:15*8,y:15*8},{x:12*8,y:15*8}],
          },
        },
        {
          tileX: 7, tileY: 10, sprite: 'npc_b', name: 'SCHOLAR',
          dialog:         ['AH, A NEW FACE!'],  // fallback
          dialogBranches: [
            {
              requires: ['rewarded'],
              lines: ['LOOKS LIKE THE VILLAGER\nWAS PLEASED WITH YOUR\nADVENTURE. WELL DONE!'],
            },
            {
              requires: ['hasKey'],
              excludes: ['rewarded'],
              lines: ['THAT KEY YOU CARRY...\nIT OPENS THE CRYSTAL\nCHAMBER DEEP INSIDE!'],
            },
            {
              lines: [
                'AH, A NEW FACE!',
                'PRESS Z NEAR ANY NPC\nTO SPEAK WITH THEM.',
                'F5 SAVES, F9 LOADS.',
              ],
            },
          ],
        },
      ],
      // Called every time this scene loads
      onEnter() {
        // Spawn overworld pickups if not already collected
        if (!getFlag('coinOW1')) spawnPickup(10*8, 8*8, 'coin');
        if (!getFlag('coinOW2')) spawnPickup(18*8, 20*8, 'coin');
        if (!getFlag('heartOW'))  spawnPickup(25*8, 6*8, 'heart');
      },
    };
  })(),

  cave: (() => {
    const cols = CAVE_COLS, rows = CAVE_ROWS;
    return {
      worldCols: cols, worldRows: rows, bgColor: 30,
      playerStart: { tileX: 3, tileY: 8 },
      music: 'cave',
      layerBG: cvBg, layerObjects: cvObj, layerCollision: cvCol,
      portals: [
        { tileX: 1, tileY: 8, targetScene: 'overworld', targetTileX: 34, targetTileY: 8 },
      ],
      npcs: [
        {
          tileX: 12, tileY: 8, sprite: 'npc_b', name: 'CAVE SAGE',
          dialog:         ['...'],
          dialogBranches: [
            {
              requires: ['enteredCave'],
              excludes: ['foundCrystal'],
              lines: [
                'THE CRYSTAL LIES\nFURTHER IN.',
                'FIND THE KEY AND THE\nCHAMBER WILL OPEN.',
              ],
            },
            {
              requires: ['foundCrystal'],
              lines: ['YOU FOUND IT! RETURN\nTO THE VILLAGE AND\nTELL THE VILLAGER.'],
            },
            // First-visit branch has no requires — but onEnter handles the cutscene.
            {
              lines: ['SEEK THE CRYSTAL\nTHAT LIES WITHIN\nTHESE WALLS.'],
            },
          ],
        },
      ],
      onEnter() {
        // Spawn cave pickups
        if (!getFlag('keyCave'))    spawnPickup(10*8, 6*8, 'key');
        if (!getFlag('crystalCave')) spawnPickup(13*8, 8*8, 'coin');
        if (!getFlag('heartCave'))   spawnPickup(8*8, 14*8, 'heart');

        // First cave entry: run the cutscene after NPCs are spawned
        if (!getFlag('enteredCave')) {
          // Find the sage NPC entity (most recently spawned with npcData.name='CAVE SAGE')
          const sageId = world.query('npcData').find(
            id => world.get(id,'npcData').name === 'CAVE SAGE'
          );
          if (sageId !== undefined) {
            setTimeout(() => cutscene.run(buildCaveEntryCutscene(sageId)), 100);
          }
        }
      },
    };
  })(),
};

registerScenes(SCENE_DATA);
setSaveKey('pixelCanvas_zelda_v5');

// Quest watcher: picking up the key and being in the cave sets foundCrystal
// (simplified — in a real game you'd have a proper puzzle/boss)
onFlags(['hasKey', 'enteredCave'], () => {
  if (!getFlag('foundCrystal')) {
    setFlag('foundCrystal');
    showNote('YOU FOUND THE CRYSTAL!');
    sound.playSFX('confirm');
    emitBurst(13*8+4, 8*8+4, 'levelup');
  }
});

// Track coin pickup flags so we don't respawn on re-entry
onFlags(['coinOW1'], () => {}, { once: false });  // placeholder to show pattern

// ================================================================
// HUD SETUP
// ================================================================
hud.setMaxHp(6);
hud.setHp(6);
hud.setCoins(0);

// ================================================================
// ENTITY INIT
// ================================================================
playerId = world.createEntity({
  persistent: true,
  player:     true,
  transform:  { x: 15 * TILE_SIZE, y: 15 * TILE_SIZE },
  velocity:   { dx: 0, dy: 0, speed: 60 },
  animator:   createAnimator(CLIPS_PLAYER, 'idle'),
  collider:   true,
});

// ================================================================
// MAIN LOOP
// ================================================================
let elapsed = 0, lastTime = 0;
let fps = 0, fpsTimer = 0, fpsFrames = 0;

loadScene('overworld');
if (saveLoad.hasSave()) { if (saveLoad.load()) showNote('SAVE LOADED'); }

// Track which pickup entities were collected this session (flag by position)
// Simple approach: pickups destroyed when collected, re-spawned on scene entry
// gated by a flag set at collection time. Gate-setting is manual per pickup type:
world.query('pickup').forEach(id => {}); // no-op, just showing access pattern

// Coin collection flags (patched on pickup):
const _origAddCoins = hud.addCoins.bind(hud);
// Track collectible position → flag linkage in spawnPickup
const _pickupFlags = new Map();  // entityId → flagName

function spawnPickupFlagged(wx, wy, type, flagName) {
  if (getFlag(flagName)) return; // already collected
  const id = spawnPickup(wx, wy, type);
  _pickupFlags.set(id, flagName);
  return id;
}

function sysPickupFlags() {
  for (const [id, flagName] of [..._pickupFlags]) {
    if (!world.has(id, 'pickup')) {
      // Entity was destroyed → mark flag as collected
      setFlag(flagName);
      _pickupFlags.delete(id);
    }
  }
}

// Override onEnter to use flagged pickups
SCENE_DATA.overworld.onEnter = function() {
  spawnPickupFlagged(10*8, 8*8,  'coin',  'coinOW1');
  spawnPickupFlagged(18*8, 20*8, 'coin',  'coinOW2');
  spawnPickupFlagged(25*8, 6*8,  'heart', 'heartOW');
};
SCENE_DATA.cave.onEnter = function() {
  spawnPickupFlagged(10*8, 6*8,  'key',   'keyCave');
  spawnPickupFlagged(13*8, 8*8,  'coin',  'crystalCave');
  spawnPickupFlagged(8*8,  14*8, 'heart', 'heartCave');

  if (!getFlag('enteredCave')) {
    const sageId = world.query('npcData').find(
      id => world.get(id,'npcData').name === 'CAVE SAGE'
    );
    if (sageId !== undefined) {
      setTimeout(() => cutscene.run(buildCaveEntryCutscene(sageId)), 80);
    }
  }
};

function loop(ts) {
  const delta = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts; elapsed += delta;
  fpsFrames++; fpsTimer += delta;
  if (fpsTimer >= 0.5) { fps = Math.round(fpsFrames / fpsTimer); fpsTimer = fpsFrames = 0; }

  // Engine subsystems
  engineTick(delta);
  updateTransition(delta);

  // Logic
  input.update();
  sysInput();
  sysAI(delta);
  sysMovement(delta);
  sysSpatialHash();
  sysCamera();
  sysSceneTransition();
  sysAnimation(delta);
  sysDialog(elapsed);
  sysPickups();
  sysPickupFlags();
  sysFootsteps(delta);
  sysPortalSparkles(delta);

  // Render
  clearBuffer(_scenes[worldState.currentScene]?.bgColor ?? 0);
  drawTilemap(worldState.layerBG,      elapsed);
  drawTilemap(worldState.layerObjects, elapsed);
  sysRender();
  renderParticles();  // after entities, before HUD
  renderHUD();        // overlays top strip
  renderDialog(elapsed);
  renderSaveNote();
  flushBuffer();
  renderTransitionOverlay();

  // Debug HUD
  const ptf = world.get(playerId, 'transform');
  document.getElementById('debug').textContent =
    `FPS: ${fps}  SCENE: ${worldState.currentScene}\n` +
    `PLAYER: ${ptf?.x|0},${ptf?.y|0}  TILE: ${ptf?.x/TILE_SIZE|0},${ptf?.y/TILE_SIZE|0}\n` +
    `CAM: ${camera.x},${camera.y}  WORLD: ${worldState.w}x${worldState.h}px\n` +
    `FLAGS: met=${+getFlag('metVillager')} cave=${+getFlag('enteredCave')} ` +
    `key=${+getFlag('hasKey')} crystal=${+getFlag('foundCrystal')} rew=${+getFlag('rewarded')}\n` +
    `HP: ${hud.hp}/${hud.maxHp}  COINS: ${hud.coins}  ` +
    `SCRIPT: ${cutscene.isRunning()?'running':'idle'}`;

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
