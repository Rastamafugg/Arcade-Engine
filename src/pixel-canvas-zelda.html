<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pixel Canvas v5.2 — Overworld Demo (Enhanced)</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0f;
    display: flex; align-items: center; justify-content: center;
    width: 100vw; height: 100vh; overflow: hidden;
  }
  canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
  #debug {
    position: fixed; top: 8px; left: 8px;
    color: #0f0; font: 9px/1.5 monospace; pointer-events: none; white-space: pre;
    background: rgba(0,0,0,0.55); padding: 4px 6px; border-radius: 2px;
  }
  #hint {
    position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%);
    color: #555; font: 9px monospace; white-space: pre; text-align: center;
    pointer-events: none;
  }
</style>
</head>
<body>
<canvas id="screen"></canvas>
<div id="debug"></div>
<div id="hint">WASD: move  |  Z: talk/open/use item  |  X: attack  |  E/Q: cycle items  |  M: minimap  |  F5: save  |  F9: load</div>

<script src="pixel-canvas-engine.js"></script>

<script>
'use strict';

// ================================================================
// SPRITES
// ================================================================
const SPRITES = {
  // ---- Terrain ----
  grass: [
     9, 9, 8, 9, 9, 9, 8, 9,   8, 9, 9, 9, 8, 9, 9, 8,
     9, 9, 8, 9, 9, 8, 9, 9,  11,11,11, 9,11,11,11,11,
    11,11,11,11,11,11,11,11,  12,11,11,11,12,11,11,12,
    11,11,12,11,11,11,12,11,  11,12,11,11,11,12,11,11,
  ],
  stone: [
    22,21,22,22,22,22,21,22,  21,22,22,22,21,22,22,22,
    22,22,22,21,22,22,22,21,  23,23,23,23,23,23,23,23,
    22,22,22,23,22,22,22,23,  22,23,22,22,22,23,22,22,
    23,22,22,22,23,22,22,22,  22,22,23,22,22,22,23,22,
  ],
  wall: [
    24,24,28,24,24,24,28,24,  28,29,29,29,29,29,29,28,
    24,29,24,24,24,24,29,24,  24,29,24,24,24,24,29,24,
    28,29,29,29,29,29,29,28,  24,29,24,24,24,24,29,24,
    24,29,24,24,24,24,29,24,  28,29,29,29,29,29,29,28,
  ],
  cave_wall: [
    30,30,29,30,30,30,29,30,  29,14,14,14,14,14,14,29,
    30,14,30,30,30,30,14,30,  30,14,30,31,31,30,14,30,
    29,14,14,14,14,14,14,29,  30,14,30,30,30,30,14,30,
    30,14,31,30,30,31,14,30,  29,14,14,14,14,14,14,29,
  ],
  cave_floor: [
    13,13,24,13,13,13,24,13,  24,13,13,13,24,13,13,24,
    13,13,24,13,13,24,13,13,  23,23,23,13,23,23,23,23,
    23,23,23,23,23,23,23,23,  13,23,23,23,13,23,23,13,
    23,13,23,23,23,13,23,23,  23,23,13,23,23,23,13,23,
  ],
  cave_floor_b2: [
    30,30,29,30,30,30,30,30,  30,30,30,30,29,30,30,30,
    30,30,30,29,30,30,30,30,  23,23,23,30,23,23,23,23,
    23,23,23,23,23,23,23,23,  30,23,23,23,30,23,23,30,
    23,30,23,23,23,30,23,23,  23,23,30,23,23,23,30,23,
  ],
  cave_floor_b3: [
    14,14,30,14,14,14,14,14,  14,14,14,14,30,14,14,14,
    14,14,14,30,14,14,14,14,  30,30,30,14,30,30,30,30,
    30,30,30,30,30,30,30,30,  14,30,30,30,14,30,30,14,
    30,14,30,30,30,14,30,30,  30,30,14,30,30,30,14,30,
  ],
  // Boss chamber floor — deepest, blood-tinged
  cave_floor_b4: [
    14,30,14,14,14,14,30,14,  14,14,14,30,14,14,14,14,
    30,14,14,14,30,14,14,14,  26,26,26,14,26,26,26,26,
    26,26,26,26,26,26,26,26,  14,26,26,26,14,26,26,14,
    26,14,26,26,26,14,26,26,  26,26,14,26,26,26,14,26,
  ],
  water0: [
    18,17,18,18,18,17,18,18,  18,18,17,18,18,18,17,18,
    15,18,18,18,15,18,18,18,  18,15,18,18,18,15,18,18,
    18,18,18,15,18,18,18,15,  18,18,15,18,18,18,15,18,
    17,18,18,18,17,18,18,18,  18,17,18,18,18,17,18,18,
  ],
  water1: [
    18,18,17,18,18,18,17,18,  17,18,18,18,17,18,18,18,
    18,18,18,15,18,18,18,15,  18,18,15,18,18,18,15,18,
    15,18,18,18,15,18,18,18,  18,15,18,18,18,15,18,18,
    18,18,18,17,18,18,18,17,  18,18,17,18,18,18,17,18,
  ],
  // ---- Decor ----
  tree: [
    null,null, 8,null,null, 8,null,null,
    null, 8,   8,  8,  8,  8,  8,null,
       8,  8,  8,  9,  9,  8,  8,  8,
    null, 8,   9,  8,  8,  9,  8,null,
    null,null, 8,  8,  8,  8,null,null,
    null,null,null, 3,null,null,null,null,
    null,null,null, 3,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  flower: [
    null,null,null, 7,null,null,null,null,
    null,null, 7,   7,  7,null,null,null,
    null,null,null, 7,null,null,null,null,
    null, 8,null,null,null, 7,null,null,
       8, 9,  8,null,null, 7,  7,null,
    null, 8,null,null,null, 7,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  crystal: [
    null,null,19,null,null,null,null,null,
    null,19,  18,  19,null,null,null,null,
      19, 18,  20,  18,  19,null,null,null,
    null,19,  18,  19,null,null,null,null,
    null,null,19,null,null,19,  18,  19,
    null,null,null,null,19, 18,  20,  18,
    null,null,null,null,null,19,null,null,
    null,null,null,null,null,null,null,null,
  ],
  portal: [
    null,null,25,25,25,null,null,null,
    null,25,  19,18,19,  25,null,null,
      25,19,  18,20,18,  19,  25,null,
      25,18,  20,25,20,  18,  25,null,
      25,19,  18,20,18,  19,  25,null,
    null,25,  19,18,19,  25,null,null,
    null,null,25,25,25,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  stairs_up: [
    22,22,22,22,22,22,22,22,
    null,20,20,20,20,20,20,null,
    null,null,20,20,20,20,null,null,
    null,null,null,20,20,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  stairs_down: [
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,20,20,null,null,null,
    null,null,20,20,20,20,null,null,
    null,20,20,20,20,20,20,null,
    22,22,22,22,22,22,22,22,
    null,null,null,null,null,null,null,null,
  ],
  // ---- Items ----
  coin_item: [
    null,null,null,null,null,null,null,null,
    null,null, 7, 7, 7,null,null,null,
    null, 7,   4,  7,  4,  7,null,null,
    null, 7,   7,  7,  7,  7,null,null,
    null, 7,   4,  7,  4,  7,null,null,
    null,null, 7, 7, 7,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  heart_item: [
    null,null,null,null,null,null,null,null,
    null,27,27,null,27,27,null,null,
    27, 27,27,27,27,27,27,null,
    27, 27,27,27,27,27,27,null,
    null,27,27,27,27,27,null,null,
    null,null,27,27,27,null,null,null,
    null,null,null,27,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  key_item: [
    null,null, 7, 7, 7,null,null,null,
    null, 7,   4,  4,  4,  7,null,null,
    null, 7,   4,null, 4,  7,null,null,
    null, 7,   4,  4,  4,  7,null,null,
    null,null, 7, 3,null,null,null,null,
    null,null,null, 3,null,null,null,null,
    null,null,null, 3, 3,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  potion_item: [
    null,null,null, 5, 5,null,null,null,
    null,null,null, 5, 5,null,null,null,
    null,null,18,  18, 18, 18,null,null,
    null,18,  19,  18, 18, 19, 18,null,
    null,18,  18,  18, 18, 18, 18,null,
    null,18,  18,  18, 18, 18, 18,null,
    null,null,18,  18, 18, 18,null,null,
    null,null,null,null,null,null,null,null,
  ],
  bomb_item: [
    null,null,null, 3,null,null,null,null,
    null,null, 3,null, 3,null,null,null,
    null,null,null, 3,null,null,null,null,
    null,null,22,22,22,null,null,null,
    null,22,  23, 23, 23, 22,null,null,
    null,22,  23, 23, 23, 22,null,null,
    null,null,22,22,22,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  sword_item: [
    null,null,null,null,null, 7,20,null,
    null,null,null,null,20,20,null,null,
    null,null,null,20,22,null,null,null,
    null,null,20,22,null, 3,null,null,
    null,20,22,null, 3,null,null,null,
    20,null,null, 3,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  bow_item: [
    null,null, 3,null,null,null,null,null,
    null, 3,null, 3,null,null,null,null,
       3,null,null, 3,null,null,null,null,
       3,null,null,null, 3,null, 7,null,
       3,null,null,null, 3, 7, 7,null,
       3,null,null, 3, 7,null,null,null,
    null, 3,null, 3,null,null,null,null,
    null,null, 3,null,null,null,null,null,
  ],
  axe_item: [
    null,null,22,22,null,null,null,null,
    null,22,21,21,22,null,null,null,
    22,21,21,21,21,22,null,null,
    22,21,22,22,21,22,null,null,
    null,22,null,null, 3,null,null,null,
    null,null,null, 3,null,null,null,null,
    null,null, 3,null,null,null,null,null,
    null, 3,null,null,null,null,null,null,
  ],
  shield_item: [
    null, 5, 5, 5, 5, 5,null,null,
       5,18,18,18,18,18, 5,null,
       5,18,20,18,20,18, 5,null,
       5,18,18,18,18,18, 5,null,
       5,18,18,18,18,18, 5,null,
    null, 5,18,18,18, 5,null,null,
    null,null, 5,18, 5,null,null,null,
    null,null,null, 5,null,null,null,null,
  ],
  // ---- Combat sprites ----
  sword_swing: [
    null,null,null,null,null, 7,20,null,
    null,null,null,null, 7,20,null,null,
    null,null,null, 7,20,null,null,null,
    null,null, 7,20,null,null,null,null,
    null, 7,20,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  arrow_proj: [
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null, 7,
    null, 3, 3, 3, 3, 3, 3, 3,
    null,null,null,null,null,null,null, 7,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  // Boss magic orb projectile
  boss_orb: [
    null,null,null,null,null,null,null,null,
    null,null,25,25,25,null,null,null,
    null,25,  19,20,19,  25,null,null,
    null,25,  20,25,20,  25,null,null,
    null,25,  19,20,19,  25,null,null,
    null,null,25,25,25,null,null,null,
    null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  // Boss minion (shade — dark, fast)
  shade_0: [
    null,null,30,30,30,30,null,null,
    null,30,  14,30,30, 14, 30,null,
    null,30,  30,30,30, 30, 30,null,
    null,31,  31,31,31, 31, 31,null,
      31,31,  14,31,31, 14, 31, 31,
    null,31,  31,31,31, 31, 31,null,
    null,31,null,null,null,null, 31,null,
    null,null,null,null,null,null,null,null,
  ],
  shade_1: [
    null,null,null,null,null,null,null,null,
    null,30,  30,30,30, 30, 30,null,
    null,30,  14,30,30, 14, 30,null,
    null,31,  31,31,31, 31, 31,null,
    null,null, 31,31,31, 31,null,null,
      31,31,  14,31,31, 14, 31, 31,
    null,31,null,null,null,null, 31,null,
    null,null,null,null,null,null,null,null,
  ],
  // ---- NPCs ----
  npc_a: [
    null,null,  7,  7,  7,  7,null,null,
    null,  7, 24,  7,  7, 24,  7,null,
    null,  7,  7,  7,  7,  7,  7,null,
    null,  4,  4,  4,  4,  4,  4,null,
       4,  4,  5,  4,  4,  5,  4,  4,
    null,  4,  5,  5,  5,  5,  4,null,
    null,  5,null,null,null,null,  5,null,
    null,  5,null,null,null,null,  5,null,
  ],
  npc_b: [
    null,null,  5,  5,  5,  5,null,null,
    null,  5, 13,  5,  5, 13,  5,null,
    null,  5,  5,  5,  5,  5,  5,null,
    null, 27, 27, 27, 27, 27, 27,null,
    27, 27,  6, 27, 27,  6, 27, 27,
    null, 27,  6,  6,  6,  6, 27,null,
    null,  6,null,null,null,null,  6,null,
    null,  6,null,null,null,null,  6,null,
  ],
  // ---- Player ----
  player_d0: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6, 24,  6,  6, 24,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,  5,  5,null,null,  5,null,null,
    null,null,  5,null,null,null,null,null,
  ],
  player_d1: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6, 24,  6,  6, 24,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,null,null,null,  5,  5,null,null,
    null,null,null,null,null,  5,null,null,
  ],
  player_idle: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6, 24,  6,  6, 24,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,  5,null,null,null,null,  5,null,
    null,  5,null,null,null,null,  5,null,
  ],
  player_u0: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6,  6, 24, 24,  6,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,  5,  5,null,null,  5,null,null,
    null,null,  5,null,null,null,null,null,
  ],
  player_u1: [
    null,null,  6,  6,  6,  6,null,null,
    null,  6,  6, 24, 24,  6,  6,null,
    null,  6,  6,  6,  6,  6,  6,null,
    null, 16, 16, 16, 16, 16, 16,null,
      16, 16,  5, 16, 16,  5, 16, 16,
    null, 16,  5,  5,  5,  5, 16,null,
    null,null,null,null,  5,  5,null,null,
    null,null,null,null,null,  5,null,null,
  ],
  player_s0: [
    null,null,  6,  6,  6,null,null,null,
    null,  6, 24,  6,  6,  6,null,null,
    null,  6,  6,  6,  6,  6,null,null,
    null, 16, 16, 16, 16, 16, 16,null,
    null, 16,  5, 16, 16,  5, 16,null,
    null, 16,  5,  5,  5,  5,null,null,
    null,  5,  5,null,  5,null,null,null,
    null,null,  5,null,null,null,null,null,
  ],
  player_s1: [
    null,null,  6,  6,  6,null,null,null,
    null,  6, 24,  6,  6,  6,null,null,
    null,  6,  6,  6,  6,  6,null,null,
    null, 16, 16, 16, 16, 16, 16,null,
    null, 16,  5, 16, 16,  5, 16,null,
    null, 16,  5,  5,  5,  5,null,null,
    null,null,null,null,  5,  5,null,null,
    null,null,null,null,null,  5,null,null,
  ],
  // ---- Enemies ----
  slime_0: [
    null,null, 9, 9, 9, 9,null,null,
    null, 9,  9, 9, 9, 9, 9,null,
       9, 9, 11, 9,24, 9,11, 9,
       9, 9,  9, 9, 9, 9, 9, 9,
       9, 9,  9, 9, 9, 9, 9, 9,
       9,11,  9, 9, 9, 9,11, 9,
    null, 9,  9, 9, 9, 9, 9,null,
    null,null, 9,null,null, 9,null,null,
  ],
  slime_1: [
    null,null,null,null,null,null,null,null,
    null, 9, 9, 9, 9, 9, 9,null,
       9, 9,11, 9,24, 9,11, 9,
       9, 9, 9, 9, 9, 9, 9, 9,
       9, 9, 9, 9, 9, 9, 9, 9,
    null, 9, 9, 9, 9, 9, 9,null,
    null, 9,null,null,null,null, 9,null,
    null,null,null,null,null,null,null,null,
  ],
  bat_0: [
    14,14,null,25,25,null,14,14,
    14,null,25,25,25,25,null,14,
    null,25,25,14,14,25,25,null,
    25,25,14, 7,14, 7,14,25,
    25,25,25,25,25,25,25,25,
    null,25,25,25,25,25,null,null,
    null,null,25,null,null,25,null,null,
    null,null,null,null,null,null,null,null,
  ],
  bat_1: [
    null,null,14,25,25,14,null,null,
    null,14,25,25,25,25,14,null,
    14,25,25,14,14,25,25,14,
    25,25,14, 7,14, 7,14,25,
    null,25,25,25,25,25,null,null,
    null,null,25,25,25,null,null,null,
    null,null,null,25,null,null,null,null,
    null,null,null,null,null,null,null,null,
  ],
  skel_0: [
    null,null,20,20,20,20,null,null,
    null,20, 1,20,20, 1,20,null,
    null,20,20,20,20,20,20,null,
    null,22,20,22,22,20,22,null,
      22,null,null,22,22,null,null,22,
    null,22,22,22,22,22,22,null,
    null,22,null,22,22,null,22,null,
    null,null,null,null,null,null,null,null,
  ],
  skel_1: [
    null,null,20,20,20,20,null,null,
    null,20, 1,20,20, 1,20,null,
    null,20,20,20,20,20,20,null,
    null,22,20,22,22,20,22,null,
    null,null,22,22,22,22,null,null,
      22,22,null,22,22,null,22,22,
      22,null,null,22,22,null,null,22,
    null,null,null,null,null,null,null,null,
  ],
  // ---- Boss — Phase 1 (dark knight, aggressive melee) ----
  boss_0: [
    null, 1, 1, 1, 1, 1, 1,null,
       1,24, 1,26,26, 1,24, 1,
       1, 1,26, 1, 1,26, 1, 1,
       1,26,26,26,26,26,26, 1,
      26,26, 1,26,26, 1,26,26,
    null,26,26,26,26,26,26,null,
    null,26,null,26,26,null,26,null,
    null,26,null,null,null,null,26,null,
  ],
  boss_1: [
    null, 1, 1, 1, 1, 1, 1,null,
       1,24, 1,26,26, 1,24, 1,
       1, 1,26, 1, 1,26, 1, 1,
       1,26,26,26,26,26,26, 1,
      26,26, 1,26,26, 1,26,26,
    null,26,26,26,26,26,26,null,
    null,null,null,26,26,null,null,null,
    null,null,null,null,26,null,null,null,
  ],
  // ---- Boss — Phase 2 (mage form, glowing purple) ----
  boss_p2_0: [
    null,25,25,25,25,25,25,null,
      25,19,25,20,20,25,19,25,
      25,25,20,25,25,20,25,25,
      25,20,20,25,25,20,20,25,
      19,25,25,25,25,25,25,19,
    null,25,18,25,25,18,25,null,
    null,25,null,25,25,null,25,null,
    null,18,null,null,null,null,18,null,
  ],
  boss_p2_1: [
    null,25,25,25,25,25,25,null,
      25,19,25,20,20,25,19,25,
      25,25,20,25,25,20,25,25,
      19,20,20,25,25,20,20,19,
      25,25,25,25,25,25,25,25,
    null,19,18,25,25,18,19,null,
    null,null,null,25,25,null,null,null,
    null,18,null,null,null,null,18,null,
  ],
  // ---- Boss — Phase 3 (void form, spawner) ----
  boss_p3_0: [
    null,31,31,31,31,31,31,null,
      31,14,31,19,19,31,14,31,
      31,31,19,31,31,19,31,31,
      31,19,19,31,31,19,19,31,
      14,31,31,31,31,31,31,14,
    null,31,31,31,31,31,31,null,
    null,14,null,31,31,null,14,null,
    null,14,null,null,null,null,14,null,
  ],
  boss_p3_1: [
    null,31,31,31,31,31,31,null,
      31,14,31,19,19,31,14,31,
      31,31,19,31,31,19,31,31,
      14,19,19,31,31,19,19,14,
      31,31,31,31,31,31,31,31,
    null,14,31,31,31,31,14,null,
    null,null,null,31,31,null,null,null,
    null,14,null,null,null,null,14,null,
  ],
};

buildSpriteCache(SPRITES);

// ================================================================
// TILE ANIMATIONS
// ================================================================
registerTileAnims({
  water: { frames: ['water0','water1'], fps: 2 },
});

// ================================================================
// SOUND
// ================================================================
sound.registerTracks({
  overworld: {
    bpm: 140, loop: true,
    channels: [
      { instrument: 'square',
        notes: 'E5:0.5 G5:0.5 A5:1 E5:0.5 G5:0.5 B5:1 A5:0.5 G5:0.5 A5:0.5 E5:0.5 D5:2 R:1 C5:0.5 E5:0.5 G5:0.5 A5:1 F5:0.5 E5:0.5 D5:0.5 C5:0.5 E5:2 R:1' },
      { instrument: 'triangle',
        notes: 'A3:2 A3:2 F3:2 G3:2 A3:2 A3:2 G3:2 E3:2 C3:2 E3:2 F3:2 G3:2 A3:4' },
    ],
  },
  cave: {
    bpm: 70, loop: true,
    channels: [
      { instrument: 'sine',
        notes: 'A3:2 R:1 G3:1 F3:2 R:1 E3:1 D3:2 R:2 A2:4 R:2 E3:2 R:2 F3:2 R:2' },
      { instrument: 'triangle',
        notes: 'A2:4 R:4 F2:4 R:4 G2:4 R:4 A2:8 R:4' },
    ],
  },
  cave_deep: {
    bpm: 55, loop: true,
    channels: [
      { instrument: 'sine',
        notes: 'D3:3 R:1 C3:2 R:2 A2:4 R:2 D2:6 R:2 E2:3 R:1 F2:2 R:2 D2:8 R:4' },
      { instrument: 'triangle',
        notes: 'D2:6 R:2 C2:6 R:2 A1:8 R:8' },
    ],
  },
  boss_battle: {
    bpm: 160, loop: true,
    channels: [
      { instrument: 'square',
        notes: 'A4:0.5 A4:0.5 R:0.5 A4:0.5 C5:1 B4:1 A4:0.5 G4:0.5 A4:2 R:1 ' +
               'F4:0.5 F4:0.5 R:0.5 F4:0.5 Ab4:1 G4:1 F4:0.5 E4:0.5 F4:2 R:1 ' +
               'D4:0.5 E4:0.5 F4:1 G4:1 A4:2 G4:1 F4:1 E4:2 R:2' },
      { instrument: 'triangle',
        notes: 'A2:2 A2:2 C3:2 B2:2 A2:4 R:4 F2:2 F2:2 Ab2:2 G2:2 F2:4 R:4 D2:4 E2:4 F2:4 R:4' },
      { instrument: 'sine',
        notes: 'R:8 A5:0.25 R:0.25 A5:0.25 R:0.25 A5:0.25 R:0.25 A5:0.25 R:0.25 R:4 ' +
               'R:8 F5:0.25 R:0.25 F5:0.25 R:0.25 F5:0.25 R:0.25 F5:0.25 R:0.25 R:4' },
    ],
  },
  victory: {
    bpm: 120, loop: false,
    channels: [
      { instrument: 'square',
        notes: 'C5:0.5 E5:0.5 G5:0.5 C6:1 R:0.5 E6:0.5 G6:0.5 E6:0.5 C6:2 R:1 ' +
               'G5:0.5 B5:0.5 D6:0.5 G6:1.5 R:0.5 C6:0.5 E6:0.5 G6:1 C7:3' },
      { instrument: 'triangle',
        notes: 'C4:2 G3:2 C4:2 G3:2 C4:4 G3:4 C4:2 G3:2 C4:6' },
    ],
  },
});

sound.registerSFX({
  confirm:     { bpm:960, channels:[{ instrument:'square',   notes:'C5:0.1 E5:0.1 G5:0.2' }] },
  dialog:      { bpm:960, channels:[{ instrument:'square',   notes:'C6:0.05' }] },
  portal:      { bpm:480, channels:[{ instrument:'sine',     notes:'A4:0.1 C#5:0.1 E5:0.1 A5:0.2 R:0.1 A6:0.3' }] },
  save:        { bpm:960, channels:[{ instrument:'square',   notes:'G5:0.08 B5:0.08 D6:0.08 G6:0.15' }] },
  cancel:      { bpm:960, channels:[{ instrument:'triangle', notes:'E5:0.1 C5:0.1' }] },
  coin:        { bpm:960, channels:[{ instrument:'square',   notes:'A5:0.06 C6:0.08 E6:0.12' }] },
  hurt:        { bpm:480, channels:[{ instrument:'square',   notes:'A4:0.06 G4:0.1' }] },
  heal:        { bpm:960, channels:[{ instrument:'triangle', notes:'E5:0.08 G5:0.08 C6:0.15' }] },
  chest_open:  { bpm:480, channels:[{ instrument:'square',   notes:'C5:0.08 E5:0.08 G5:0.08 C6:0.2' },
                                     { instrument:'triangle', notes:'C3:0.44' }] },
  bomb:        { bpm:240, channels:[{ instrument:'square',   notes:'G3:0.1 F3:0.1 E3:0.1 D3:0.15' },
                                     { instrument:'triangle', notes:'C2:0.45' }] },
  potion:      { bpm:960, channels:[{ instrument:'sine',     notes:'E5:0.08 G5:0.08 B5:0.08 E6:0.15' }] },
  sword_swing: { bpm:480, channels:[{ instrument:'square',   notes:'G5:0.05 C6:0.07' }] },
  bow_fire:    { bpm:480, channels:[{ instrument:'triangle', notes:'E6:0.04 A5:0.06' }] },
  axe_swing:   { bpm:240, channels:[{ instrument:'square',   notes:'D4:0.1 A3:0.12' }] },
  enemy_die:   { bpm:480, channels:[{ instrument:'square',   notes:'C4:0.06 A3:0.08 F3:0.1' }] },
  stairs:      { bpm:480, channels:[{ instrument:'triangle', notes:'C4:0.05 E4:0.05 G4:0.08' }] },
  weapon_get:  { bpm:480, channels:[{ instrument:'square',   notes:'C5:0.1 E5:0.1 G5:0.1 C6:0.2' }] },
  alert:       { bpm:480, channels:[{ instrument:'sine',     notes:'A4:0.1 C#5:0.1 E5:0.1 A5:0.2 R:0.1 A6:0.3' }] },
  boss_hit:    { bpm:240, channels:[{ instrument:'square',   notes:'G3:0.08 E3:0.12' },
                                     { instrument:'triangle', notes:'C2:0.2' }] },
  boss_phase:  { bpm:120, channels:[{ instrument:'square',   notes:'A3:0.3 R:0.1 A3:0.3 R:0.1 C4:0.5 E4:0.8' },
                                     { instrument:'sine',     notes:'A2:1.5 R:0.5' }] },
  boss_summon: { bpm:240, channels:[{ instrument:'sine',     notes:'A4:0.1 G4:0.1 F4:0.1 E4:0.15 D4:0.2 C4:0.3' }] },
  boss_magic:  { bpm:480, channels:[{ instrument:'sine',     notes:'E6:0.06 A6:0.08 E7:0.1' }] },
  victory:     { bpm:480, channels:[{ instrument:'square',   notes:'C5:0.1 E5:0.1 G5:0.1 C6:0.3 R:0.1 G5:0.3 C6:0.5' }] },
});

// ================================================================
// ENEMY SYSTEM
// ================================================================
const ENEMY_DEFS = {
  slime: {
    frames: ['slime_0','slime_1'],
    speed: 28, aggroRange: 64,
    hp: 2, maxHp: 2,
    damage: 1, knockback: 30,
    drop: 'coin',
  },
  bat: {
    frames: ['bat_0','bat_1'],
    speed: 52, aggroRange: 88,
    hp: 3, maxHp: 3,
    damage: 1, knockback: 40,
    drop: 'coin',
  },
  skeleton: {
    frames: ['skel_0','skel_1'],
    speed: 22, aggroRange: 72,
    hp: 5, maxHp: 5,
    damage: 2, knockback: 55,
    drop: 'heart',
  },
  shade: {
    frames: ['shade_0','shade_1'],
    speed: 60, aggroRange: 96,
    hp: 3, maxHp: 3,
    damage: 1, knockback: 35,
    drop: 'coin',
  },
};

// Spawn a standard enemy at a tile position.
// opts.aggroGroup — string name to link into aggro table propagation.
function spawnEnemy(type, tileX, tileY, opts = {}) {
  const def = ENEMY_DEFS[type];
  if (!def) return;
  world.createEntity({
    transform: { x: tileX * TILE_SIZE, y: tileY * TILE_SIZE },
    sprite:    { name: def.frames[0], flipX: false },
    velocity:  { dx: 0, dy: 0, speed: def.speed },
    collider:  true,
    enemy: {
      type,
      speed:       def.speed,
      aggroRange:  def.aggroRange,
      aggroGroup:  opts.aggroGroup ?? null,   // ← aggro group support
      frames:      def.frames,
      frameIdx:    0,
      animTimer:   0,
      wanderTimer: Math.random() * 2,
      wanderDx:    Math.cos(Math.random() * Math.PI * 2),
      wanderDy:    Math.sin(Math.random() * Math.PI * 2),
      drop:        def.drop,
      aggrod:      false,   // tracks whether this enemy has entered chase
    },
    damageable: {
      hp: def.hp, maxHp: def.maxHp,
      iframes: 0, iframeMax: 0.45,
      team: 'enemy',
      onHit(vid) {
        const tf = world.get(vid, 'transform');
        if (tf) emitBurst(tf.x + 4, tf.y + 4, 'hit');
      },
      onDeath(vid) {
        const e  = world.get(vid, 'enemy');
        const tf = world.get(vid, 'transform');
        if (tf && e) {
          emitBurst(tf.x + 4, tf.y + 4, 'levelup');
          world.createEntity({
            transform: { x: tf.x, y: tf.y },
            sprite:    { name: e.drop + '_item', flipX: false },
            pickup:    { type: e.drop, collected: false },
          });
        }
        sound.playSFX('enemy_die');
        world.destroyEntity(vid);
      },
    },
    damager: { damage: def.damage, team: 'enemy', knockback: def.knockback },
  });
}

// ================================================================
// SKELETON SPAWNER — cave_b3 continuously respawns skeletons
// ================================================================
const B3_SPAWNER_INTERVAL = 10;  // seconds
let b3SpawnerTimer   = 0;
let b3SpawnerActive  = false;
const B3_SPAWN_POSITIONS = [
  [2, 3], [17, 3], [2, 12], [10, 3], [10, 13],
];

function resetB3Spawner() {
  b3SpawnerTimer  = B3_SPAWNER_INTERVAL;
  b3SpawnerActive = false;
}

function sysB3Spawner(delta) {
  if (!b3SpawnerActive) return;

  b3SpawnerTimer -= delta;
  if (b3SpawnerTimer <= 0) {
    b3SpawnerTimer = B3_SPAWNER_INTERVAL;

    // Spawn up to 3 skeletons at random positions (cap to avoid flooding)
    const aliveCount = world.query('enemy').filter(
      id => world.get(id,'enemy')?.type === 'skeleton'
    ).length;
    const toSpawn = Math.max(0, 3 - aliveCount);
    for (let i = 0; i < toSpawn; i++) {
      const pos = B3_SPAWN_POSITIONS[Math.floor(Math.random() * B3_SPAWN_POSITIONS.length)];
      spawnEnemy('skeleton', pos[0], pos[1]);
      emitBurst(pos[0] * TILE_SIZE + 4, pos[1] * TILE_SIZE + 4, 'portal');
    }
    if (toSpawn > 0) {
      showNote('SKELETONS RISE FROM THE DARK...', 2.0);
      sound.playSFX('boss_summon');
    }
  }
}

// ================================================================
// BOSS SYSTEM — cave_b4 three-phase boss
// ================================================================
let bossId     = -1;
let bossPhase  = 0;   // 0=inactive, 1=melee, 2=ranged, 3=summon
let bossActive = false;
let bossMagicTimer = 0;
const BOSS_MAGIC_INTERVAL = 2.2;

const BOSS_MAX_HP   = 30;
const BOSS_PHASE2_HP = 20;   // trigger P2 at ≤20 HP
const BOSS_PHASE3_HP = 10;   // trigger P3 at ≤10 HP

function spawnBoss() {
  if (getFlag('boss_dead')) return;
  bossId = world.createEntity({
    transform: { x: 9 * TILE_SIZE, y: 8 * TILE_SIZE },
    sprite:    { name: 'boss_0', flipX: false },
    velocity:  { dx: 0, dy: 0, speed: 30 },
    collider:  true,
    boss: {
      phase: 1,
      frames_p1: ['boss_0',   'boss_1'],
      frames_p2: ['boss_p2_0','boss_p2_1'],
      frames_p3: ['boss_p3_0','boss_p3_1'],
      frameIdx:  0, animTimer: 0,
    },
    damageable: {
      hp: BOSS_MAX_HP, maxHp: BOSS_MAX_HP,
      iframes: 0, iframeMax: 0.5,
      team: 'boss',
      onHit(vid) {
        const tf = world.get(vid, 'transform');
        if (tf) emitBurst(tf.x + 4, tf.y + 4, 'hit');
        sound.playSFX('boss_hit');
      },
      onDeath(vid) {
        const tf = world.get(vid, 'transform');
        if (tf) emitBurst(tf.x + 4, tf.y + 4, 'levelup');
        bossActive = false;
        bossPhase  = 0;
        bossId     = -1;
        setFlag('boss_dead');
        world.destroyEntity(vid);
        // Victory sequence
        setTimeout(() => {
          cutscene.run([
            { cmd: 'lockInput', value: true },
            { cmd: 'stopBgm' },
            { cmd: 'bgm', name: 'victory' },
            { cmd: 'wait', seconds: 0.5 },
            { cmd: 'note', text: 'THE VOID LORD HAS BEEN DEFEATED!' },
            { cmd: 'wait', seconds: 1.5 },
            { cmd: 'dialog', name: 'SYSTEM', lines: [
                'THE DARKNESS RETREATS.',
                'THE CAVE IS FREED FROM ITS CURSE.',
                'YOU HAVE PROVEN YOURSELF A TRUE HERO.',
            ]},
            { cmd: 'call', fn() {
                emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'chest');
                emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'levelup');
                emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'portal');
                hud.setMaxHp(hud.maxHp + 4);
                hud.addHp(hud.maxHp);
                sound.playSFX('victory');
            }},
            { cmd: 'note', text: '+4 MAX HP! FULL HEAL!' },
            { cmd: 'wait', seconds: 2.0 },
            { cmd: 'stopBgm' },
            { cmd: 'bgm', name: 'overworld' },
            { cmd: 'lockInput', value: false },
          ]);
        }, 100);
      },
    },
    damager: { damage: 2, team: 'boss', knockback: 60 },
  });
  bossPhase  = 1;
  bossActive = true;
  bossMagicTimer = BOSS_MAGIC_INTERVAL;
}

function _triggerBossPhase2() {
  if (bossPhase !== 1) return;
  bossPhase = 2;
  bossMagicTimer = BOSS_MAGIC_INTERVAL;
  const boss = world.get(bossId, 'boss');
  if (boss) boss.phase = 2;
  // Speed boost for phase 2
  const vel = world.get(bossId, 'velocity');
  if (vel) vel.speed = 22;

  sound.playSFX('boss_phase');
  emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'portal');
  showNote('THE VOID LORD TRANSFORMS — PHASE 2!', 3.0);
}

function _triggerBossPhase3() {
  if (bossPhase !== 2) return;
  bossPhase = 3;
  bossMagicTimer = BOSS_MAGIC_INTERVAL * 0.6;
  const boss = world.get(bossId, 'boss');
  if (boss) boss.phase = 3;
  const vel = world.get(bossId, 'velocity');
  if (vel) vel.speed = 14;

  sound.playSFX('boss_phase');
  emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'portal');
  showNote('THE VOID LORD AWAKENS ITS MINIONS — PHASE 3!', 3.0);

  // Spawn initial minions
  _spawnBossMinions();
}

function _spawnBossMinions() {
  const positions = [[5,5],[13,5],[5,11],[13,11]];
  for (const [tx, ty] of positions) {
    spawnEnemy('shade', tx, ty);
    emitBurst(tx * TILE_SIZE + 4, ty * TILE_SIZE + 4, 'portal');
  }
  sound.playSFX('boss_summon');
}

function _fireBossMagic() {
  if (!world.has(bossId, 'transform')) return;
  const bTf  = world.get(bossId, 'transform');
  const ptf  = world.get(playerId, 'transform');
  if (!bTf || !ptf) return;

  const dx   = ptf.x - bTf.x;
  const dy   = ptf.y - bTf.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;
  const spd  = 55;

  world.createEntity({
    transform: { x: bTf.x + 4, y: bTf.y + 4 },
    sprite:    { name: 'boss_orb', flipX: false },
    velocity:  { dx: (dx / dist) * spd, dy: (dy / dist) * spd, speed: spd },
    projectile: {
      lifetime: 3.5,
      team:    'boss',
      damage:  2,
      knockback: 40,
    },
  });
  sound.playSFX('boss_magic');
}

function sysBoss(delta) {
  if (!bossActive || bossId < 0) return;
  if (!world.has(bossId, 'damageable')) return;

  const dmg  = world.get(bossId, 'damageable');
  const boss = world.get(bossId, 'boss');
  const tf   = world.get(bossId, 'transform');
  const vel  = world.get(bossId, 'velocity');
  const sp   = world.get(bossId, 'sprite');
  if (!dmg || !boss || !tf || !vel) return;

  // Phase transition checks
  if (bossPhase === 1 && dmg.hp <= BOSS_PHASE2_HP) _triggerBossPhase2();
  if (bossPhase === 2 && dmg.hp <= BOSS_PHASE3_HP) _triggerBossPhase3();

  // Animate boss sprite
  boss.animTimer += delta;
  if (boss.animTimer >= 0.25) {
    boss.animTimer = 0;
    boss.frameIdx  = (boss.frameIdx + 1) % 2;
    const frames = boss.phase === 1 ? boss.frames_p1
                 : boss.phase === 2 ? boss.frames_p2
                 : boss.frames_p3;
    if (sp) sp.name = frames[boss.frameIdx];
  }

  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;

  const dx   = ptf.x - tf.x;
  const dy   = ptf.y - tf.y;
  const dist = Math.sqrt(dx * dx + dy * dy) || 1;

  if (bossPhase === 1) {
    // PHASE 1 — chase and melee
    vel.dx = (dx / dist) * vel.speed;
    vel.dy = (dy / dist) * vel.speed;

  } else if (bossPhase === 2) {
    // PHASE 2 — kite + ranged magic
    // Back away from player if too close
    if (dist < 40) {
      vel.dx = -(dx / dist) * vel.speed;
      vel.dy = -(dy / dist) * vel.speed;
    } else {
      vel.dx *= 0.85; vel.dy *= 0.85;
    }

    bossMagicTimer -= delta;
    if (bossMagicTimer <= 0) {
      bossMagicTimer = BOSS_MAGIC_INTERVAL;
      _fireBossMagic();
    }

  } else if (bossPhase === 3) {
    // PHASE 3 — slow orbit + rapid magic + periodic minion summons
    const angle = Math.atan2(dy, dx);
    const orbitR = 48;
    vel.dx = Math.cos(angle + 0.04) * vel.speed;
    vel.dy = Math.sin(angle + 0.04) * vel.speed;

    bossMagicTimer -= delta;
    if (bossMagicTimer <= 0) {
      bossMagicTimer = BOSS_MAGIC_INTERVAL * 0.5;
      _fireBossMagic();
      // Every third fire, summon another minion
      if (Math.random() < 0.33) {
        const px = [[5,5],[13,5],[5,11],[13,11]];
        const pos = px[Math.floor(Math.random() * px.length)];
        spawnEnemy('shade', pos[0], pos[1]);
        emitBurst(pos[0] * TILE_SIZE + 4, pos[1] * TILE_SIZE + 4, 'portal');
        sound.playSFX('boss_summon');
      }
    }
  }
}

// ================================================================
// ENEMY AI SYSTEM  (supports aggroGroup propagation)
// ================================================================
function sysEnemyAI(delta) {
  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;

  for (const id of world.query('enemy', 'transform', 'velocity')) {
    const tf  = world.get(id, 'transform');
    const vel = world.get(id, 'velocity');
    const e   = world.get(id, 'enemy');
    const sp  = world.get(id, 'sprite');
    const dmg = world.get(id, 'damageable');
    if (!tf || !vel || !e) continue;

    // Freeze during knockback iframe period
    if (dmg && dmg.iframes > dmg.iframeMax * 0.6) {
      vel.dx *= 0.85; vel.dy *= 0.85;
      continue;
    }

    const dx   = ptf.x - tf.x;
    const dy   = ptf.y - tf.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Check if this enemy's aggroGroup has been triggered by another member
    const groupAggrod = e.aggroGroup ? aggroTableActive(e.aggroGroup) : false;

    if ((dist < e.aggroRange && dist > 2) || groupAggrod) {
      // Chase player
      vel.dx = (dx / dist || 0) * e.speed;
      vel.dy = (dy / dist || 0) * e.speed;
      e.wanderTimer = 0;

      // Alert the aggro group when this enemy first enters chase
      if (!e.aggrod && e.aggroGroup) {
        e.aggrod = true;
        alertGroup(e.aggroGroup, tf.x, tf.y);
      }
    } else {
      // Wander
      e.wanderTimer -= delta;
      if (e.wanderTimer <= 0) {
        e.wanderTimer = 1.5 + Math.random() * 2;
        const a = Math.random() * Math.PI * 2;
        e.wanderDx = Math.cos(a);
        e.wanderDy = Math.sin(a);
        // Reset aggro tracking when returning to wander
        e.aggrod = false;
      }
      vel.dx = e.wanderDx * e.speed * 0.3;
      vel.dy = e.wanderDy * e.speed * 0.3;
    }

    // Animate
    e.animTimer += delta;
    if (e.animTimer >= 0.18) {
      e.animTimer = 0;
      e.frameIdx  = (e.frameIdx + 1) % e.frames.length;
      if (sp) sp.name = e.frames[e.frameIdx];
    }
    if (sp) sp.flipX = vel.dx < 0;
  }
}

// ================================================================
// NPC DIALOG BRANCHES
// ================================================================
const VILLAGER_BRANCHES = [
  {
    requires: ['rewarded'],
    lines: ['THANK YOU FOR CLEARING\nTHE CAVE OF EVIL!',
            'THE VILLAGE SLEEPS\nSAFELY ONCE AGAIN.'],
  },
  {
    requires: ['foundCrystal'],
    excludes: ['rewarded'],
    lines: ['YOU FOUND THE CRYSTAL!',
            'TAKE THIS REWARD FOR\nYOUR BRAVERY.'],
    setFlags:  ['rewarded'],
    addCoins: 5,
  },
  {
    requires: ['enteredCave'],
    excludes: ['foundCrystal'],
    lines: ['GOOD LUCK IN THERE.\nBEWARE THE DARKNESS.'],
  },
  {
    lines: ['THE CAVE TO THE EAST\nIS FULL OF MONSTERS.',
            'ONLY A HERO CAN\nCLEAR IT FOR US.'],
  },
];

function buildCaveEntryCutscene(sageId) {
  return [
    { cmd: 'lockInput', value: true },
    { cmd: 'move', entityId: sageId,
      targetX: 4 * TILE_SIZE, targetY: 8 * TILE_SIZE, speed: 28 },
    { cmd: 'dialog', name: 'CAVE SAGE', lines: [
        'STOP RIGHT THERE.',
        'YOU ARE THE FIRST TO\nENTER IN MANY YEARS.',
        'TAKE THIS HEART. YOU\nWILL NEED IT AHEAD.',
        'BEWARE: SLIMES LURK\nIN THE DARK. PRESS X\nTO SWING YOUR SWORD.',
        'STAIRS LEAD DEEPER.\nEACH LEVEL IS MORE\nDANGEROUS THAN THE LAST.',
    ]},
    { cmd: 'flag',  name: 'enteredCave' },
    { cmd: 'call',  fn: () => { hud.addHp(2); sound.playSFX('heal'); emitBurst(4*8+4, 8*8+4, 'sparkle'); } },
    { cmd: 'lockInput', value: false },
  ];
}

// ================================================================
// MAP BUILDERS
// ================================================================
function buildOverworld(cols, rows) {
  const bg  = Array.from({length: rows}, () => Array(cols).fill('grass'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, () => Array(cols).fill(false));

  for (let r = 4; r <= 6; r++)
    for (let c = 5; c <= 9; c++) { bg[r][c] = 'water'; col[r][c] = true; }
  for (let r = 9; r <= 11; r++)
    for (let c = 6; c <= 10; c++) bg[r][c] = 'stone';
  for (let r = 20; r <= 25; r++)
    for (let c = 15; c <= 22; c++)
      if (r === 20 || r === 25 || c === 15 || c === 22)
        { obj[r][c] = 'wall'; col[r][c] = true; }
  [[1,1],[1,4],[2,8],[3,18],[6,14],[0,12],[9,25],[11,28],[16,5],[13,8],[22,2],[24,6],
   [5,32],[12,38],[20,30],[28,5],[30,12],[32,20],[25,35]].forEach(([r,c]) => {
    if (r < rows && c < cols) { obj[r][c] = 'tree'; col[r][c] = true; }
  });
  [[3,3],[4,12],[7,3],[8,18],[13,7],[19,12],[22,28],[28,15]].forEach(([r,c]) => {
    if (r < rows && c < cols) obj[r][c] = 'flower';
  });
  obj[8][35] = 'portal';
  return { bg, objects: obj, collision: col };
}

function buildCaveL1(cols, rows) {
  const bg  = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      (r === 0 || r === rows-1 || c === 0 || c === cols-1) ? 'cave_wall' : 'cave_floor'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      r === 0 || r === rows-1 || c === 0 || c === cols-1));

  for (let r = 4; r <= 12; r++)
    for (let c = 5; c <= 14; c++)
      if ((r === 4 || r === 12 || c === 5 || c === 14) &&
          !(r === 8 && (c === 5 || c === 14)))
        { bg[r][c] = 'cave_wall'; col[r][c] = true; }

  [[2,5],[2,10],[2,16],[16,3],[16,10],[16,16],[6,8],[9,11],[7,2],[14,17]].forEach(([r,c]) => {
    if (r < rows && c < cols && !col[r][c]) obj[r][c] = 'crystal';
  });

  obj[15][17] = 'stairs_down';
  obj[8][1]  = 'portal'; col[8][1] = false;
  bg[8][0]   = 'cave_floor'; col[8][0] = false;
  return { bg, objects: obj, collision: col };
}

function buildCaveL2(cols, rows) {
  const bg  = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      (r === 0 || r === rows-1 || c === 0 || c === cols-1) ? 'cave_wall' : 'cave_floor_b2'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      r === 0 || r === rows-1 || c === 0 || c === cols-1));

  [[3,4],[3,10],[3,16],[8,7],[8,13],[14,4],[14,10],[14,16]].forEach(([r,c]) => {
    if (r < rows && c < cols) { bg[r][c] = 'cave_wall'; col[r][c] = true; }
  });
  for (let c = 4; c <= 16; c++)
    if (c !== 7 && c !== 13)
      { bg[6][c] = 'cave_wall'; col[6][c] = true; }
  for (let c = 4; c <= 16; c++)
    if (c !== 7 && c !== 13)
      { bg[11][c] = 'cave_wall'; col[11][c] = true; }

  [[2,2],[2,8],[2,14],[16,2],[16,8],[16,14],[5,2],[5,17],[9,2],[9,17]].forEach(([r,c]) => {
    if (r < rows && c < cols && !col[r][c]) obj[r][c] = 'crystal';
  });

  obj[15][2] = 'stairs_up';
  obj[2][17] = 'stairs_down';
  return { bg, objects: obj, collision: col };
}

function buildCaveL3(cols, rows) {
  const bg  = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      (r === 0 || r === rows-1 || c === 0 || c === cols-1) ? 'cave_wall' : 'cave_floor_b3'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      r === 0 || r === rows-1 || c === 0 || c === cols-1));

  for (let r = 4; r <= 12; r++) {
    bg[r][5]  = 'cave_wall'; col[r][5]  = true;
    bg[r][14] = 'cave_wall'; col[r][14] = true;
  }
  for (let c = 5; c <= 14; c++) {
    bg[5][c]  = 'cave_wall'; col[5][c]  = true;
    bg[12][c] = 'cave_wall'; col[12][c] = true;
  }
  col[8][5]  = false; bg[8][5]  = 'cave_floor_b3';
  col[8][14] = false; bg[8][14] = 'cave_floor_b3';
  col[5][9]  = false; bg[5][9]  = 'cave_floor_b3';
  col[12][9] = false; bg[12][9] = 'cave_floor_b3';

  [[2,2],[2,8],[2,17],[16,2],[16,8],[16,17],[3,12],[15,12]].forEach(([r,c]) => {
    if (r < rows && c < cols && !col[r][c]) obj[r][c] = 'crystal';
  });

  obj[15][17] = 'stairs_up';
  obj[15][2]  = 'stairs_down';   // ← NEW: descend to B4 boss floor

  return { bg, objects: obj, collision: col };
}

// ---- NEW: Boss floor — cave B4 ----
function buildCaveL4(cols, rows) {
  const bg  = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      (r === 0 || r === rows-1 || c === 0 || c === cols-1) ? 'cave_wall' : 'cave_floor_b4'));
  const obj = Array.from({length: rows}, () => Array(cols).fill(null));
  const col = Array.from({length: rows}, (_, r) =>
    Array.from({length: cols}, (_, c) =>
      r === 0 || r === rows-1 || c === 0 || c === cols-1));

  // Sealed boss chamber — outer ring of walls
  for (let r = 3; r <= 14; r++) {
    bg[r][3]  = 'cave_wall'; col[r][3]  = true;
    bg[r][16] = 'cave_wall'; col[r][16] = true;
  }
  for (let c = 3; c <= 16; c++) {
    bg[3][c]  = 'cave_wall'; col[3][c]  = true;
    bg[14][c] = 'cave_wall'; col[14][c] = true;
  }
  // Chamber doorway (locked until boss dead via portal guard)
  col[8][3] = false; bg[8][3] = 'cave_floor_b4';

  // Dark crystals around the chamber interior
  [[5,5],[5,14],[11,5],[11,14],[8,5],[8,14],[5,9],[11,9]].forEach(([r,c]) => {
    if (!col[r][c]) obj[r][c] = 'crystal';
  });

  // Stairs back up to B3 — outside the chamber
  obj[15][17] = 'stairs_up';

  return { bg, objects: obj, collision: col };
}

// ================================================================
// SCENE DIMENSIONS
// ================================================================
const OW_COLS   = 40, OW_ROWS   = 36;
const CAVE_COLS = 20, CAVE_ROWS = 18;

const { bg: owBg,  objects: owObj,  collision: owCol  } = buildOverworld(OW_COLS, OW_ROWS);
const { bg: c1Bg,  objects: c1Obj,  collision: c1Col  } = buildCaveL1(CAVE_COLS, CAVE_ROWS);
const { bg: c2Bg,  objects: c2Obj,  collision: c2Col  } = buildCaveL2(CAVE_COLS, CAVE_ROWS);
const { bg: c3Bg,  objects: c3Obj,  collision: c3Col  } = buildCaveL3(CAVE_COLS, CAVE_ROWS);
const { bg: c4Bg,  objects: c4Obj,  collision: c4Col  } = buildCaveL4(CAVE_COLS, CAVE_ROWS);

// ================================================================
// SCENES
// ================================================================
const SCENE_DATA = {
  overworld: (() => ({
    worldCols: OW_COLS, worldRows: OW_ROWS, bgColor: 0,
    playerStart: { tileX: 15, tileY: 15 },
    music: 'overworld',
    layerBG: owBg, layerObjects: owObj, layerCollision: owCol,
    portals: [
      { tileX: 35, tileY: 8, targetScene: 'cave', targetTileX: 3, targetTileY: 8 },
    ],
    chests: [
      {
        tileX: 14, tileY: 20, flagName: 'chest_ow_bomb',
        loot: [{
          sprite: 'bomb_item',
          label: 'BOMB OBTAINED! [E/Q: cycle  Z: use]',
          onPickup() {
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'bomb_item'); hud.selectedSlot = slot; }
          },
        }],
      },
      {
        tileX: 9, tileY: 10, flagName: 'chest_ow_potion',
        loot: [{
          sprite: 'potion_item',
          label: 'POTION OBTAINED!',
          onPickup() {
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'potion_item'); hud.selectedSlot = slot; }
            showNote('POTION! USE WITH Z.');
          },
        }],
      },
      {
        tileX: 34, tileY: 8, flagName: 'chest_ow_axe',
        loot: [{
          sprite: 'axe_item',
          label: 'WAR AXE OBTAINED! [Heavy melee]',
          onPickup() {
            sound.playSFX('weapon_get');
            emitBurst(34*8+4, 8*8+4, 'levelup');
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'axe_item'); hud.selectedSlot = slot; }
            showNote('WAR AXE — MASSIVE DAMAGE!');
          },
        }],
      },
      {
        tileX: 18, tileY: 18, flagName: 'chest_ow_shield',
        loot: [{
          sprite: 'shield_item',
          label: 'SHIELD OBTAINED! [Passive: reduces damage]',
          onPickup() {
            sound.playSFX('weapon_get');
            emitBurst(18*8+4, 18*8+4, 'levelup');
            setFlag('hasShield');
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'shield_item'); }
            showNote('SHIELD — PASSIVE DEFENCE +1');
          },
        }],
      },
    ],
    npcs: [
      {
        tileX: 12, tileY: 12, sprite: 'npc_a', name: 'VILLAGER',
        dialog:         ['...'],
        dialogBranches: VILLAGER_BRANCHES,
        patrol: {
          speed: 20, waypointIdx: 0,
          waypoints: [{x:12*8,y:12*8},{x:15*8,y:12*8},{x:15*8,y:15*8},{x:12*8,y:15*8}],
        },
      },
      {
        tileX: 7, tileY: 10, sprite: 'npc_b', name: 'SCHOLAR',
        dialog: ['AH, A NEW FACE!'],
        dialogBranches: [
          {
            requires: ['rewarded'],
            lines: ['LOOKS LIKE THE VILLAGER\nWAS PLEASED WITH YOUR\nADVENTURE. WELL DONE!'],
          },
          {
            requires: ['boss_dead'],
            excludes: ['rewarded'],
            lines: ['THE VOID LORD IS SLAIN!\nLEGEND WILL REMEMBER\nYOUR NAME.'],
          },
          {
            requires: ['hasKey'],
            excludes: ['rewarded'],
            lines: ['THAT KEY YOU CARRY...\nIT OPENS THE CRYSTAL\nCHAMBER DEEP INSIDE!'],
          },
          {
            lines: [
              'AH, A NEW FACE!',
              'PRESS Z NEAR A CHEST\nOR NPC TO INTERACT.',
              'PRESS X TO ATTACK\nWITH YOUR SWORD.',
              'WEAPON CHESTS ARE\nHIDDEN ACROSS THE LAND.\nEXPLORE WELL!',
              'E/Q CYCLES ITEMS.\nZ USES THE SELECTED ITEM.',
              'M TOGGLES THE MINIMAP.',
            ],
          },
        ],
      },
    ],
    onEnter() {
      spawnPickupFlagged(10*8,  8*8, 'coin',  'coinOW1');
      spawnPickupFlagged(18*8, 20*8, 'coin',  'coinOW2');
      spawnPickupFlagged(25*8,  6*8, 'heart', 'heartOW');
      spawnPickupFlagged(32*8,  3*8, 'coin',  'coinOW3');
      spawnPickupFlagged( 3*8, 22*8, 'coin',  'coinOW4');
      spawnPickupFlagged(22*8, 30*8, 'coin',  'coinOW5');
    },
  }))(),

  // ---- Cave Level 1 (slimes) ----
  cave: (() => ({
    worldCols: CAVE_COLS, worldRows: CAVE_ROWS, bgColor: 30,
    playerStart: { tileX: 3, tileY: 8 },
    music: 'cave',
    layerBG: c1Bg, layerObjects: c1Obj, layerCollision: c1Col,
    portals: [
      { tileX: 1,  tileY: 8,  targetScene: 'overworld', targetTileX: 34, targetTileY: 8 },
      { tileX: 17, tileY: 15, targetScene: 'cave_b2',   targetTileX: 3,  targetTileY: 14,
        onActivate() { sound.playSFX('stairs'); showNote('DESCENDING TO B2...'); } },
    ],
    chests: [
      {
        tileX: 11, tileY: 6, flagName: 'chest_cave_key',
        loot: [{
          sprite: 'key_item',
          label: 'KEY OBTAINED!',
          onPickup() {
            setFlag('hasKey');
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'key_item'); hud.selectedSlot = slot; }
          },
        }],
      },
      {
        tileX: 16, tileY: 14, flagName: 'chest_cave_potion',
        loot: [{
          sprite: 'potion_item',
          label: 'POTION FOUND IN THE DEPTHS!',
          onPickup() {
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'potion_item'); hud.selectedSlot = slot; }
          },
        }],
      },
    ],
    npcs: [
      {
        tileX: 12, tileY: 8, sprite: 'npc_b', name: 'CAVE SAGE',
        dialog: ['...'],
        dialogBranches: [
          {
            requires: ['foundCrystal'],
            lines: ['YOU FOUND IT! RETURN\nTO THE VILLAGE AND\nTELL THE VILLAGER.'],
          },
          {
            requires: ['enteredCave', 'hasKey'],
            excludes: ['foundCrystal'],
            lines: ['THE CRYSTAL LIES\nFURTHER IN.', 'THE KEY WILL OPEN\nTHE CHAMBER.'],
          },
          {
            requires: ['enteredCave'],
            excludes: ['hasKey'],
            lines: ['A CHEST LIES TO THE\nNORTH-EAST. THE KEY\nINSIDE OPENS ALL.'],
          },
          {
            lines: ['SEEK THE CRYSTAL\nTHAT LIES WITHIN\nTHESE WALLS.',
                    'STAIRS IN THE SOUTH-EAST\nLEAD DEEPER. BEWARE\nBATS AND WORSE.'],
          },
        ],
      },
    ],
    onEnter() {
      spawnPickupFlagged(13*8, 8*8, 'coin',  'crystalCave');
      spawnPickupFlagged( 8*8,14*8, 'heart', 'heartCave');

      if (!getFlag('cave_cleared')) {
        spawnEnemy('slime',  7,  3);
        spawnEnemy('slime', 16,  5);
        spawnEnemy('slime',  5, 14);
      }

      if (!getFlag('enteredCave')) {
        const sageId = world.query('npcData').find(
          id => world.get(id,'npcData')?.name === 'CAVE SAGE'
        );
        if (sageId !== undefined) {
          setTimeout(() => cutscene.run(buildCaveEntryCutscene(sageId)), 80);
        }
      }
    },
  }))(),

  // ---- Cave Level 2 (bats — shared aggro group) ----
  cave_b2: (() => ({
    worldCols: CAVE_COLS, worldRows: CAVE_ROWS, bgColor: 30,
    playerStart: { tileX: 3, tileY: 8 },
    music: 'cave',
    layerBG: c2Bg, layerObjects: c2Obj, layerCollision: c2Col,
    portals: [
      { tileX: 2,  tileY: 15, targetScene: 'cave',    targetTileX: 16, targetTileY: 14,
        onActivate() { sound.playSFX('stairs'); showNote('ASCENDING TO B1...'); } },
      { tileX: 17, tileY: 2,  targetScene: 'cave_b3', targetTileX: 16, targetTileY: 14,
        onActivate() { sound.playSFX('stairs'); showNote('DESCENDING TO B3...'); } },
    ],
    chests: [
      {
        tileX: 10, tileY: 14, flagName: 'chest_b2_heart',
        loot: [{
          sprite: 'heart_item',
          label: 'HEART CONTAINER! +2 MAX HP',
          onPickup() {
            hud.setMaxHp(hud.maxHp + 2);
            hud.addHp(2);
            sound.playSFX('heal');
            emitBurst(10*8+4, 14*8+4, 'levelup');
            showNote('+2 MAX HP!');
          },
        }],
      },
      {
        tileX: 16, tileY: 8, flagName: 'chest_b2_potion',
        loot: [{
          sprite: 'potion_item',
          label: 'POTION FOUND!',
          onPickup() {
            const slot = hud.items.indexOf(null);
            if (slot >= 0) { hud.setItem(slot, 'potion_item'); hud.selectedSlot = slot; }
          },
        }],
      },
    ],
    npcs: [],
    onEnter() {
      spawnPickupFlagged( 9*8, 3*8, 'coin',  'coinB2a');
      spawnPickupFlagged(14*8, 3*8, 'coin',  'coinB2b');
      spawnPickupFlagged( 2*8, 8*8, 'heart', 'heartB2');

      // Clear any stale aggro from a prior visit
      clearAggroGroup('cave_b2_bats');

      // All four bats share one aggro group — spotting any one alerts all
      spawnEnemy('bat',  5,  3, { aggroGroup: 'cave_b2_bats' });
      spawnEnemy('bat', 14,  8, { aggroGroup: 'cave_b2_bats' });
      spawnEnemy('bat',  8, 14, { aggroGroup: 'cave_b2_bats' });
      spawnEnemy('bat', 16,  3, { aggroGroup: 'cave_b2_bats' });

      if (!getFlag('sawB2Warning')) {
        setFlag('sawB2Warning');
        showNote('B2 — BATS HUNT IN PACKS!\nALERTING ONE ALERTS ALL.', 3.0);
      }
    },
  }))(),

  // ---- Cave Level 3 (skeleton spawner) ----
  cave_b3: (() => ({
    worldCols: CAVE_COLS, worldRows: CAVE_ROWS, bgColor: 14,
    playerStart: { tileX: 3, tileY: 8 },
    music: 'cave_deep',
    layerBG: c3Bg, layerObjects: c3Obj, layerCollision: c3Col,
    portals: [
      { tileX: 16, tileY: 15, targetScene: 'cave_b2', targetTileX: 16, targetTileY: 2,
        onActivate() { sound.playSFX('stairs'); showNote('ASCENDING TO B2...'); } },
      { tileX: 2,  tileY: 15, targetScene: 'cave_b4', targetTileX: 3,  targetTileY: 8,
        onActivate() { sound.playSFX('stairs'); showNote('DESCENDING TO B4 — THE VOID...'); } },
    ],
    chests: [
      {
        tileX: 9, tileY: 8, flagName: 'chest_b3_treasure',
        loot: [
          {
            sprite: 'coin_item',
            label: 'ANCIENT GOLD! +10 COINS',
            onPickup() {
              hud.addCoins(10);
              sound.playSFX('coin');
              emitBurst(9*8+4, 8*8+4, 'coin');
              showNote('ANCIENT HOARD! +10 COINS');
            },
          },
          {
            sprite: 'heart_item',
            label: '+2 MAX HP',
            onPickup() {
              hud.setMaxHp(hud.maxHp + 2);
              hud.addHp(2);
              sound.playSFX('heal');
              showNote('+2 MAX HP FROM ANCIENT RELIC!');
            },
          },
        ],
      },
    ],
    npcs: [],
    onEnter() {
      spawnPickupFlagged( 2*8,  2*8, 'coin',  'coinB3a');
      spawnPickupFlagged(17*8,  2*8, 'coin',  'coinB3b');
      spawnPickupFlagged( 2*8, 16*8, 'coin',  'coinB3c');

      // No pre-placed enemies — the spawner handles all skeletons
      resetB3Spawner();
      b3SpawnerActive = true;
      // First wave immediately
      spawnEnemy('skeleton',  2,  3);
      spawnEnemy('skeleton', 17,  3);
      emitBurst(2*8+4, 3*8+4, 'portal');
      emitBurst(17*8+4, 3*8+4, 'portal');

      if (!getFlag('sawB3Warning')) {
        setFlag('sawB3Warning');
        showNote('B3 — ENDLESS SKELETONS RISE.\nSTAIRS DOWN LEAD TO SOMETHING WORSE.', 3.5);
      }
    },
    onExit() {
      b3SpawnerActive = false;
    },
  }))(),

  // ---- Cave Level 4 — Boss Floor ----
  cave_b4: (() => ({
    worldCols: CAVE_COLS, worldRows: CAVE_ROWS, bgColor: 14,
    playerStart: { tileX: 3, tileY: 8 },
    music: 'cave_deep',
    layerBG: c4Bg, layerObjects: c4Obj, layerCollision: c4Col,
    portals: [
      { tileX: 17, tileY: 15, targetScene: 'cave_b3', targetTileX: 2, targetTileY: 14,
        onActivate() { sound.playSFX('stairs'); showNote('ASCENDING TO B3...'); } },
    ],
    chests: [],
    npcs: [],
    onEnter() {
      spawnPickupFlagged( 1*8,  2*8, 'coin',  'coinB4a');
      spawnPickupFlagged(18*8,  2*8, 'heart', 'heartB4');

      // Reset boss state on each entry (unless already dead)
      bossActive = false;
      bossId     = -1;
      bossPhase  = 0;

      if (getFlag('boss_dead')) {
        showNote('THE VOID LORD LIES DEFEATED.\nPEACE RETURNS TO THE DEEP.', 3.0);
        return;
      }

      // Boss intro cutscene fires on first entry
      setTimeout(() => {
        cutscene.run([
          { cmd: 'lockInput', value: true },
          { cmd: 'wait', seconds: 0.4 },
          { cmd: 'note', text: 'YOU FEEL AN ANCIENT DREAD...' },
          { cmd: 'wait', seconds: 1.2 },
          // Boss materialises with particle burst
          { cmd: 'call', fn() {
              spawnBoss();
              emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'portal');
              emitBurst(9 * TILE_SIZE + 4, 8 * TILE_SIZE + 4, 'levelup');
          }},
          { cmd: 'wait', seconds: 0.6 },
          { cmd: 'bgm', name: 'boss_battle' },
          { cmd: 'dialog', name: 'VOID LORD', lines: [
              'SO. A MORTAL DARES\nENTER MY SANCTUM.',
              'YOU HAVE FOUGHT WELL\nTO REACH THIS PLACE.',
              'BUT YOUR JOURNEY ENDS\nHERE, IN DARKNESS.',
              'I WILL CONSUME YOUR\nSOUL AND ADD IT TO\nMY ENDLESS VOID.',
              'FACE ME — AND DESPAIR.',
          ]},
          { cmd: 'wait', seconds: 0.3 },
          { cmd: 'lockInput', value: false },
        ]);
      }, 80);
    },
  }))(),
};

// ================================================================
// PICKUP FLAGS HELPER
// ================================================================
function spawnPickupFlagged(wx, wy, type, flagName) {
  if (getFlag(flagName)) return;
  const id = world.createEntity({
    transform: { x: wx, y: wy },
    sprite:    { name: type + '_item', flipX: false },
    pickup:    { type, collected: false },
    pickupFlag: { name: flagName },
  });
  return id;
}

// ================================================================
// PLAYER STATE
// ================================================================
let playerId = -1;
const playerFacing = { dx: 0, dy: 1 };
let attackCooldown = 0;
const ATTACK_CD_MAX = 0.35;

// ================================================================
// SCENE LOADING
// ================================================================
const worldState = {
  currentScene: '',
  w: 0, h: 0,
  layerBG: [], layerObjects: [], layerCollision: [],
};

function loadScene(name, tileX, tileY) {
  const def = SCENE_DATA[name];
  if (!def) return;

  // Deactivate spawners from previous scene
  b3SpawnerActive = false;
  if (worldState.currentScene === 'cave_b4') {
    bossActive = false;
  }

  // Clear all non-persistent entities
  for (const id of [...world.allIds])
    if (!world.has(id, 'persistent')) world.destroyEntity(id);

  worldState.currentScene  = name;
  worldState.w             = def.worldCols * TILE_SIZE;
  worldState.h             = def.worldRows * TILE_SIZE;
  worldState.layerBG       = def.layerBG;
  worldState.layerObjects  = def.layerObjects;
  worldState.layerCollision = def.layerCollision;

  // Register collision layer for LOS / movement
  setCollisionLayer(def.layerCollision, def.worldCols, def.worldRows);

  // Spawn player
  const start = def.playerStart;
  const sx = tileX !== undefined ? tileX * TILE_SIZE : start.tileX * TILE_SIZE;
  const sy = tileY !== undefined ? tileY * TILE_SIZE : start.tileY * TILE_SIZE;

  playerId = world.createEntity({
    transform: { x: sx, y: sy },
    sprite:    { name: 'player_idle', flipX: false },
    velocity:  { dx: 0, dy: 0, speed: 60 },
    collider:  true,
    player:    { animTimer: 0, frameIdx: 0, moving: false },
    damageable: {
      hp: hud.hp, maxHp: hud.maxHp,
      iframes: 0, iframeMax: 0.8,
      team: 'player',
      onHit(vid) { sound.playSFX('hurt'); emitBurst(sx, sy, 'hit'); },
    },
    persistent: true,
  });

  // Spawn portals
  for (const p of (def.portals || [])) {
    world.createEntity({
      transform: { x: p.tileX * TILE_SIZE, y: p.tileY * TILE_SIZE },
      portal: { ...p },
    });
  }

  // Spawn chests
  for (const c of (def.chests || [])) {
    if (!getFlag(c.flagName)) {
      world.createEntity({
        transform: { x: c.tileX * TILE_SIZE, y: c.tileY * TILE_SIZE },
        sprite:    { name: 'wall', flipX: false },
        chest:     { flagName: c.flagName, loot: c.loot, open: false },
        collider:  true,
      });
    }
  }

  // Spawn NPCs
  for (const n of (def.npcs || [])) {
    world.createEntity({
      transform: { x: n.tileX * TILE_SIZE, y: n.tileY * TILE_SIZE },
      sprite:    { name: n.sprite, flipX: false },
      velocity:  { dx: 0, dy: 0, speed: n.patrol?.speed ?? 0 },
      collider:  true,
      npcData:   { name: n.name, dialog: n.dialog, branches: n.dialogBranches ?? [] },
      patrol:    n.patrol ?? null,
    });
  }

  sound.playBGM(def.music);
  def.onEnter?.();
}

// ================================================================
// INPUT
// ================================================================
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true;  });
window.addEventListener('keyup',   e => { keys[e.code] = false; });

const input = {
  update() {
    this.left  = !!(keys['KeyA'] || keys['ArrowLeft']);
    this.right = !!(keys['KeyD'] || keys['ArrowRight']);
    this.up    = !!(keys['KeyW'] || keys['ArrowUp']);
    this.down  = !!(keys['KeyS'] || keys['ArrowDown']);
    this.attack = !!keys['KeyX'];
    this.action = !!keys['KeyZ'];
  },
  left:false, right:false, up:false, down:false, attack:false, action:false,
};

let _actionHeld = false;
let _attackHeld = false;

function sysInput() {
  const ptf = world.get(playerId, 'transform');
  const vel = world.get(playerId, 'velocity');
  const pl  = world.get(playerId, 'player');
  if (!ptf || !vel || !pl || cutscene.isInputLocked()) {
    if (vel) { vel.dx = 0; vel.dy = 0; }
    return;
  }

  let dx = 0, dy = 0;
  if (input.left)  dx -= 1;
  if (input.right) dx += 1;
  if (input.up)    dy -= 1;
  if (input.down)  dy += 1;

  if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
  vel.dx = dx * vel.speed;
  vel.dy = dy * vel.speed;
  pl.moving = dx !== 0 || dy !== 0;
}

function sysTrackFacing() {
  const vel = world.get(playerId, 'velocity');
  if (!vel) return;
  if (Math.abs(vel.dx) > Math.abs(vel.dy)) {
    playerFacing.dx = vel.dx > 0 ? 1 : -1;
    playerFacing.dy = 0;
  } else if (vel.dy !== 0) {
    playerFacing.dx = 0;
    playerFacing.dy = vel.dy > 0 ? 1 : -1;
  }
}

// ================================================================
// PLAYER ANIMATION
// ================================================================
function sysPlayerAnim(delta) {
  const pl = world.get(playerId, 'player');
  const sp = world.get(playerId, 'sprite');
  const vel = world.get(playerId, 'velocity');
  if (!pl || !sp || !vel) return;

  if (!pl.moving) { sp.name = 'player_idle'; return; }

  pl.animTimer += delta;
  if (pl.animTimer >= 0.15) {
    pl.animTimer = 0;
    pl.frameIdx  = (pl.frameIdx + 1) % 2;
  }

  const idx = pl.frameIdx;
  if (playerFacing.dx !== 0) {
    sp.name  = idx === 0 ? 'player_s0' : 'player_s1';
    sp.flipX = playerFacing.dx < 0;
  } else if (playerFacing.dy < 0) {
    sp.name  = idx === 0 ? 'player_u0' : 'player_u1';
    sp.flipX = false;
  } else {
    sp.name  = idx === 0 ? 'player_d0' : 'player_d1';
    sp.flipX = false;
  }
}

// ================================================================
// ATTACK SYSTEM
// ================================================================
function sysPlayerAttack(delta) {
  attackCooldown = Math.max(0, attackCooldown - delta);
  if (!input.attack || attackCooldown > 0 || cutscene.isInputLocked()) return;

  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;

  attackCooldown = ATTACK_CD_MAX;
  sound.playSFX('sword_swing');

  const ax = ptf.x + playerFacing.dx * TILE_SIZE;
  const ay = ptf.y + playerFacing.dy * TILE_SIZE;

  // Spawn a swing hitbox entity
  const swingId = world.createEntity({
    transform: { x: ax, y: ay },
    sprite:    { name: 'sword_swing', flipX: playerFacing.dx < 0 },
    swing:     { lifetime: 0.12, team: 'player', damage: 1, knockback: 50 },
    damager:   { damage: 1, team: 'player', knockback: 50 },
  });
  setTimeout(() => { if (world.has(swingId, 'swing')) world.destroyEntity(swingId); }, 130);
}

// ================================================================
// MOVEMENT + COLLISION
// ================================================================
function sysMovement(delta) {
  for (const id of world.query('transform', 'velocity')) {
    const tf  = world.get(id, 'transform');
    const vel = world.get(id, 'velocity');
    if (!tf || !vel) continue;

    const nx = tf.x + vel.dx * delta;
    const ny = tf.y + vel.dy * delta;

    const solX = isSolid(nx, tf.y, worldState.layerCollision, worldState.w / TILE_SIZE);
    const solY = isSolid(tf.x, ny, worldState.layerCollision, worldState.w / TILE_SIZE);

    tf.x = solX ? tf.x : nx;
    tf.y = solY ? tf.y : ny;

    // Clamp to world bounds
    tf.x = Math.max(0, Math.min(worldState.w - TILE_SIZE, tf.x));
    tf.y = Math.max(0, Math.min(worldState.h - TILE_SIZE, tf.y));
  }
}

function isSolid(wx, wy, layer, cols) {
  const tx = Math.floor(wx / TILE_SIZE);
  const ty = Math.floor(wy / TILE_SIZE);
  const rows = layer.length;
  if (tx < 0 || ty < 0 || tx >= cols || ty >= rows) return true;
  return layer[ty]?.[tx] === true;
}

// ================================================================
// CAMERA
// ================================================================
function sysCamera() {
  const ptf = world.get(playerId, 'transform');
  if (ptf) camera.follow(ptf.x + 4, ptf.y + 4, worldState.w, worldState.h);
}

// ================================================================
// PORTAL SYSTEM
// ================================================================
function sysPortalSparkles(delta) {
  // Portal tiles emit sparkle particles periodically
}

function sysSceneTransition() {
  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;

  for (const id of world.query('portal')) {
    const p  = world.get(id, 'portal');
    const tf = world.get(id, 'transform');
    if (!p || !tf) continue;
    const dx = ptf.x - tf.x;
    const dy = ptf.y - tf.y;
    if (Math.abs(dx) < TILE_SIZE && Math.abs(dy) < TILE_SIZE) {
      p.onActivate?.();
      loadScene(p.targetScene, p.targetTileX, p.targetTileY);
      return;
    }
  }
}

// ================================================================
// DAMAGE SYSTEM
// ================================================================
function sysDamage(delta) {
  // Tick iframes
  for (const id of world.query('damageable')) {
    const d = world.get(id, 'damageable');
    if (d && d.iframes > 0) d.iframes = Math.max(0, d.iframes - delta);
  }

  // Damagers hit damageables of different team
  for (const did of world.query('damager', 'transform')) {
    const dmgr = world.get(did, 'damager');
    const dtf  = world.get(did, 'transform');
    if (!dmgr || !dtf) continue;

    for (const tid of world.query('damageable', 'transform')) {
      if (tid === did) continue;
      const dmgb = world.get(tid, 'damageable');
      const ttf  = world.get(tid, 'transform');
      if (!dmgb || !ttf) continue;
      if (dmgr.team === dmgb.team) continue;
      if (dmgb.iframes > 0) continue;

      const dx = ttf.x - dtf.x;
      const dy = ttf.y - dtf.y;
      if (Math.abs(dx) > TILE_SIZE * 1.5 || Math.abs(dy) > TILE_SIZE * 1.5) continue;

      // Hit
      dmgb.hp -= dmgr.damage;
      dmgb.iframes = dmgb.iframeMax;
      dmgb.onHit?.(tid);

      // Sync player hp to HUD
      if (tid === playerId) hud.setHp(dmgb.hp);

      if (dmgb.hp <= 0) {
        dmgb.onDeath?.(tid);
      }
    }
  }
}

// ================================================================
// PICKUP SYSTEM
// ================================================================
function sysPickups() {
  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;
  for (const id of world.query('pickup', 'transform')) {
    const p  = world.get(id, 'pickup');
    const tf = world.get(id, 'transform');
    if (!p || !tf || p.collected) continue;
    const dx = ptf.x - tf.x;
    const dy = ptf.y - tf.y;
    if (Math.abs(dx) < TILE_SIZE * 1.2 && Math.abs(dy) < TILE_SIZE * 1.2) {
      p.collected = true;
      if (p.type === 'coin')  { hud.addCoins(1); sound.playSFX('coin'); }
      if (p.type === 'heart') { hud.addHp(2);    sound.playSFX('heal'); }
      world.destroyEntity(id);
    }
  }
}

function sysPickupFlags() {
  for (const id of world.query('pickupFlag')) {
    if (!world.has(id, 'pickup')) continue;
    const p  = world.get(id, 'pickup');
    const pf = world.get(id, 'pickupFlag');
    if (p?.collected && pf) {
      setFlag(pf.name);
      world.destroyEntity(id);
    }
  }
}

// ================================================================
// CHEST LOOT
// ================================================================
function sysChestLoot(delta) {
  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;

  for (const id of world.query('chest', 'transform')) {
    const ch = world.get(id, 'chest');
    const tf = world.get(id, 'transform');
    if (!ch || !tf || ch.open) continue;

    const dx = ptf.x - tf.x;
    const dy = ptf.y - tf.y;
    const near = Math.abs(dx) < TILE_SIZE * 1.5 && Math.abs(dy) < TILE_SIZE * 1.5;

    if (near && input.action && !_actionHeld) {
      _actionHeld = true;
      ch.open = true;
      setFlag(ch.flagName);
      sound.playSFX('chest_open');
      emitBurst(tf.x + 4, tf.y + 4, 'chest');
      for (const item of (ch.loot || [])) {
        item.onPickup?.();
        if (item.label) showNote(item.label, 2.5);
      }
      world.destroyEntity(id);
    }
  }
  if (!input.action) _actionHeld = false;
}

// ================================================================
// NPC DIALOG SYSTEM  (simplified)
// ================================================================
let activeDialog = null;
let dialogTimer  = 0;

function sysDialog(elapsed) {
  const ptf = world.get(playerId, 'transform');
  if (!ptf) return;

  if (activeDialog) return;  // don't open new dialogs while one is running

  if (input.action && !_actionHeld) {
    for (const id of world.query('npcData', 'transform')) {
      const n  = world.get(id, 'npcData');
      const tf = world.get(id, 'transform');
      if (!n || !tf) continue;
      const dx = ptf.x - tf.x;
      const dy = ptf.y - tf.y;
      if (Math.abs(dx) < TILE_SIZE * 2 && Math.abs(dy) < TILE_SIZE * 2) {
        // Find matching branch
        let lines = n.dialog;
        for (const b of (n.branches || [])) {
          const req = b.requires ?? [];
          const exc = b.excludes ?? [];
          if (req.every(f => getFlag(f)) && exc.every(f => !getFlag(f))) {
            lines = b.lines;
            if (b.setFlags)  b.setFlags.forEach(setFlag);
            if (b.addCoins)  hud.addCoins(b.addCoins);
            if (b.addHp)     hud.addHp(b.addHp);
            break;
          }
        }
        cutscene.run(lines.map(l => ({ cmd: 'dialog', name: n.name, lines: [l] })));
        _actionHeld = true;
        return;
      }
    }
  }
}

// ================================================================
// SPATIAL HASH + AI STUBS
// ================================================================
function sysSpatialHash() {}
function sysAI(delta) {
  // NPC patrol
  for (const id of world.query('npcData', 'patrol', 'transform', 'velocity')) {
    const pt = world.get(id, 'patrol');
    const tf = world.get(id, 'transform');
    const v  = world.get(id, 'velocity');
    if (!pt || !tf || !v || !pt.waypoints?.length) continue;
    const wp  = pt.waypoints[pt.waypointIdx];
    const dx  = wp.x - tf.x;
    const dy  = wp.y - tf.y;
    const dist = Math.sqrt(dx*dx+dy*dy);
    if (dist < 2) {
      pt.waypointIdx = (pt.waypointIdx + 1) % pt.waypoints.length;
      v.dx = 0; v.dy = 0;
    } else {
      v.dx = (dx/dist) * pt.speed;
      v.dy = (dy/dist) * pt.speed;
    }
  }
}

// ================================================================
// PROJECTILE SYSTEM
// ================================================================
function sysProjectile(delta) {
  for (const id of world.query('projectile', 'transform', 'velocity')) {
    const proj = world.get(id, 'projectile');
    const tf   = world.get(id, 'transform');
    const vel  = world.get(id, 'velocity');
    if (!proj || !tf || !vel) continue;

    proj.lifetime -= delta;
    if (proj.lifetime <= 0) { world.destroyEntity(id); continue; }

    // Check hit against player
    const ptf = world.get(playerId, 'transform');
    if (ptf) {
      const dx = ptf.x - tf.x;
      const dy = ptf.y - tf.y;
      if (Math.abs(dx) < TILE_SIZE && Math.abs(dy) < TILE_SIZE) {
        const d = world.get(playerId, 'damageable');
        if (d && d.iframes <= 0 && proj.team !== 'player') {
          d.hp -= proj.damage;
          d.iframes = d.iframeMax;
          hud.setHp(d.hp);
          sound.playSFX('hurt');
          emitBurst(ptf.x+4, ptf.y+4, 'hit');
        }
        world.destroyEntity(id);
        continue;
      }
    }

    // Destroy on solid collision
    const cols = Math.floor(worldState.w / TILE_SIZE);
    if (isSolid(tf.x, tf.y, worldState.layerCollision, cols)) {
      world.destroyEntity(id);
    }
  }
}

// ================================================================
// RENDER SYSTEM
// ================================================================
function sysRender() {
  // Draw all entities with a sprite and transform
  for (const id of world.query('transform', 'sprite')) {
    const tf = world.get(id, 'transform');
    const sp = world.get(id, 'sprite');
    if (!tf || !sp || !spriteCache[sp.name]) continue;
    const [sx, sy] = camera.toScreen(tf.x, tf.y);
    if (sx < -TILE_SIZE*2 || sx > 180 || sy < -TILE_SIZE*2 || sy > 160) continue;
    drawSprite(sp.name, sx | 0, sy | 0, sp.flipX);
  }
}

// ================================================================
// HUD — boss HP bar
// ================================================================
function renderBossBar() {
  if (!bossActive || bossId < 0) return;
  const dmg = world.get(bossId, 'damageable');
  if (!dmg) return;

  const BAR_W = 80, BAR_H = 4;
  const bx    = (LOGICAL_W - BAR_W) / 2;
  const by    = LOGICAL_H - 14;
  const pct   = Math.max(0, dmg.hp / dmg.maxHp);

  fillRectPx(bx - 1, by - 1, BAR_W + 2, BAR_H + 2, 0);
  fillRectPx(bx, by, BAR_W, BAR_H, 23);
  fillRectPx(bx, by, Math.round(BAR_W * pct), BAR_H,
    bossPhase === 3 ? 31 : bossPhase === 2 ? 25 : 26);
  drawText('VOID LORD', bx, by - 8, 20);
}

// ================================================================
// FOOTSTEP + SAVE NOTE STUBS
// ================================================================
let _saveNoteText = '', _saveNoteTimer = 0;
function showNote(txt, dur = 2.0) { _saveNoteText = txt; _saveNoteTimer = dur; }
function renderSaveNote() {
  if (_saveNoteTimer <= 0) return;
  _saveNoteTimer -= 0.016;
  drawText(_saveNoteText, 4, LOGICAL_H - 22, 20);
}
function sysFootsteps() {}

// ================================================================
// SAVE / LOAD
// ================================================================
const saveLoad = {
  hasSave() { try { return !!localStorage.getItem('pxz_save'); } catch(e) { return false; } },
  save() {
    try {
      const ptf = world.get(playerId, 'transform');
      localStorage.setItem('pxz_save', JSON.stringify({
        scene: worldState.currentScene,
        px: ptf?.x, py: ptf?.y,
        hp: hud.hp, maxHp: hud.maxHp, coins: hud.coins,
        items: hud.items,
        flags: [...flags],
      }));
      return true;
    } catch(e) { return false; }
  },
  load() {
    try {
      const d = JSON.parse(localStorage.getItem('pxz_save'));
      if (!d) return false;
      hud.setMaxHp(d.maxHp ?? 6);
      hud.setHp(d.hp ?? d.maxHp ?? 6);
      for (let i = 0; i < (d.items?.length ?? 0); i++) if (d.items[i]) hud.setItem(i, d.items[i]);
      (d.flags ?? []).forEach(f => setFlag(f));
      loadScene(d.scene ?? 'overworld',
        d.px !== undefined ? Math.floor(d.px / TILE_SIZE) : undefined,
        d.py !== undefined ? Math.floor(d.py / TILE_SIZE) : undefined);
      hud.setHp(d.hp ?? hud.maxHp);
      return true;
    } catch(e) { return false; }
  },
};

window.addEventListener('keydown', e => {
  if (e.code === 'KeyF' && e.key === 'F5') { e.preventDefault(); if (saveLoad.save()) showNote('SAVED!'); }
  if (e.code === 'KeyF' && e.key === 'F9') { e.preventDefault(); if (saveLoad.load()) showNote('LOADED!'); }
});

// ================================================================
// MINIMAP TOGGLE
// ================================================================
let minimapVisible = true;
window.addEventListener('keydown', e => {
  if (e.code === 'KeyM') minimapVisible = !minimapVisible;
});

// ================================================================
// MAIN LOOP
// ================================================================
let elapsed = 0, lastTime = 0;
let fps = 0, fpsTimer = 0, fpsFrames = 0;

loadScene('overworld');
if (saveLoad.hasSave()) { if (saveLoad.load()) showNote('SAVE LOADED'); }

function loop(ts) {
  const delta = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts; elapsed += delta;
  fpsFrames++; fpsTimer += delta;
  if (fpsTimer >= 0.5) { fps = Math.round(fpsFrames / fpsTimer); fpsTimer = fpsFrames = 0; }

  // Engine subsystems
  engineTick(delta);

  // Game logic
  input.update();
  sysInput();
  sysTrackFacing();
  sysPlayerAttack(delta);
  sysPlayerAnim(delta);
  sysAI(delta);
  sysEnemyAI(delta);        // includes aggroGroup propagation
  sysBoss(delta);            // ← three-phase boss logic
  sysB3Spawner(delta);       // ← skeleton spawner on B3
  sysMovement(delta);
  sysCamera();
  sysSceneTransition();
  sysDamage(delta);
  sysProjectile(delta);
  sysPickups();
  sysPickupFlags();
  sysChestLoot(delta);
  sysDialog(elapsed);
  sysFootsteps();

  // Render
  clearBuffer(_scenes?.[worldState.currentScene]?.bgColor ?? 0);
  drawTilemap(worldState.layerBG,      elapsed);
  drawTilemap(worldState.layerObjects, elapsed);
  sysRender();
  renderParticles();
  renderHUD();
  renderBossBar();    // ← boss HP bar
  if (minimapVisible) {
    renderMinimap({
      corner:     'bottomRight',
      fixedMapW:  42,
      fixedMapH:  38,
      showCamera: true,
    });
  }
  renderSaveNote();
  flushBuffer();

  // Debug
  const ptf = world.get(playerId, 'transform');
  document.getElementById('debug').textContent =
    `FPS: ${fps}  SCENE: ${worldState.currentScene}\n` +
    `PLAYER: ${ptf?.x|0},${ptf?.y|0}  FACING: ${playerFacing.dx},${playerFacing.dy}\n` +
    `CAM: ${camera.x},${camera.y}  WORLD: ${worldState.w}x${worldState.h}px\n` +
    `FLAGS: cave=${+getFlag('enteredCave')} key=${+getFlag('hasKey')} boss=${+getFlag('boss_dead')} shield=${+getFlag('hasShield')}\n` +
    `HP: ${hud.hp}/${hud.maxHp}  COINS: ${hud.coins}  ` +
    `SLOT: ${hud.selectedSlot ?? 'none'}  ITEMS: [${hud.items.map(i=>i?i.replace('_item',''):'-').join('|')}]\n` +
    `WEAPON: ${hud.selectedSlot !== null && hud.items[hud.selectedSlot] ? hud.items[hud.selectedSlot].replace('_item','').toUpperCase() : 'BASIC SWORD'}\n` +
    `ATTACK_CD: ${attackCooldown.toFixed(2)}  ENEMIES: ${world.query('enemy').length}` +
    (bossActive ? `  BOSS: P${bossPhase} HP:${world.get(bossId,'damageable')?.hp ?? '?'}` : '');

  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);
</script>
</body>
</html>
